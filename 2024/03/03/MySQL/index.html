<!DOCTYPE html>
<html>
  <!-- meta/link... -->
  



<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <!-- Global site tag (gtag.js) - Google Analytics -->


  <title>MySQL | 余年的个人博客</title>

  <link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico">
  <link rel="stylesheet" href="https://at.alicdn.com/t/font_1911880_c1nvbyezg17.css">
  <link href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
  <link href="/js/swiper/swiper@5.4.1.min.css" rel="stylesheet">
  
  
  
  
<link rel="stylesheet" href="/css/animate.min.css">

  
<link rel="stylesheet" href="/css/style.css">

  
  
    <link href="https://unpkg.com/@fancyapps/ui@5.0/dist/fancybox/fancybox.css" rel="stylesheet">
  
  
    
<link rel="stylesheet" href="/js/shareJs/share.min.css">

  
  <style>
        @media (max-width: 992px) {
            #waifu {
                display: none;
            }
        }
    </style>
    <script defer src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

    
    
    <!-- 依赖于jquery和vue -->
    <script src="https://unpkg.com/jquery@3.5.1/dist/jquery.min.js"></script>
    <script src="https://unpkg.com/vue@2.6.11/dist/vue.min.js"></script>

    <!-- import link -->
    
        
            
        
            
        
    
    <!-- import script -->
    
        
            
        
            
        
    

<meta name="generator" content="Hexo 7.0.0"></head>

  
  <!-- 预加载动画 -->
  
  
  <div class="preloader_6" id="loader">
  <div class="loader"></div>
</div>
  <script>
    var endLoading = function () {
      document.body.style.overflow = 'auto';
      document.getElementById('loader').classList.add("loaded");
    }
    window.addEventListener('DOMContentLoaded', endLoading);
  </script>


  <body>
    <!-- 判断是否为暗黑风格 -->
    <!-- 判断是否为黑夜模式 -->
<script defer>
  let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');

  if (isDark) {
    $(document.body).addClass('darkModel');
  }
</script>

    <!-- 需要在上面加载的js -->
    <script>
  function loadScript(src, cb) {
    return new Promise(resolve => {
      setTimeout(function () {
        var HEAD = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        if (cb) {
          if (JSON.stringify(cb)) {
            for (let p in cb) {
              if (p == "onload") {
                script[p] = () => {
                  cb[p]()
                  resolve()
                }
              } else {
                script[p] = cb[p]
                script.onload = resolve
              }
            }
          } else {
            script.onload = () => {
              cb()
              resolve()
            };
          }
        } else {
          script.onload = resolve
        }
        script.setAttribute("src", src);
        HEAD.appendChild(script);
      });
    });
  }

  //https://github.com/filamentgroup/loadCSS
  var loadCSS = function (src) {
    return new Promise(resolve => {
      setTimeout(function () {
        var link = document.createElement('link');
        link.rel = "stylesheet";
        link.href = src;
        link.onload = resolve;
        document.getElementsByTagName("head")[0].appendChild(link);
      });
    });
  };

</script> 

<!-- 轮播图所需要的js -->
<script src="/js/swiper/swiper.min.js"></script>
<script src="/js/swiper/vue-awesome-swiper.js"></script>
<script src="/js/swiper/swiper.animate1.0.3.min.js"></script>

<script type="text/javascript">
  Vue.use(window.VueAwesomeSwiper)
</script>


  <script src="/js/vue-typed-js/index.js"></script>


<!-- 首页的公告滚动插件的js需要重新加载 -->
<script src="/js/vue-seamless-scroll/index.js"></script>

<!-- 打字机效果js -->
<script src="https://unpkg.com/typed.js@2.0.11"></script>


    <div id="safearea">
      <main class="main" id="pjax-container">
        <!-- 头部导航 -->
        
<header class="header  " 
  id="navHeader"
  style="position: fixed;
  left: 0; top: 0; z-index: 10;width: 100%;"
>
  <div class="header-content">
    <div class="bars">
      <div id="appDrawer" class="sidebar-image">
  <div class="drawer-box-icon">
    <i class="fas fa-bars" aria-hidden="true" @click="showDialogDrawer"></i>
  </div>
  
  <transition name="fade">
    <div class="drawer-box_mask" v-cloak style="display: none;" v-show="visible" @click.self="cancelDialogDrawer">
    </div>
  </transition>
  <div class="drawer-box" :class="{'active': visible}">
    <div class="drawer-box-head bg-color">
      <img class="drawer-box-head_logo lazyload placeholder" src="/medias/logo.png" class="lazyload placeholder" data-srcset="/medias/logo.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="logo">
      <h3 class="drawer-box-head_title">余年的个人博客</h3>
      <h5 class="drawer-box-head_desc"></h5>
    </div>
    
    <div class="drawer-box-content">
      <ul class="drawer-box-content_menu">
        
        
          <li class="drawer-box-content_item">
            <a href="https://hnuyl16.github.io/">
              <i class="fas fa-github" aria-hidden="true"></i>
              <span>Github</span>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>

<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appDrawer',
    data: {
      visible: false,
      top: 0,
      openArr: [],
    },
    computed: {
    },
    mounted() {
    },
    methods: {
      isOpen(index) {
        if (this.openArr.includes(index)) {
          return true;
        } else {
          return false;
        }
      },
      openOrCloseMenu(curIndex) {
        const index = this.openArr.indexOf(curIndex);
        if (index !== -1) {
          this.openArr.splice(index, 1);
        } else {
          this.openArr.push(curIndex);
        }
      },
      showDialogDrawer() {
        this.visible = true;
        // 防止页面滚动，只能让弹框滚动
        this.top = $(document).scrollTop()
        body.style.cssText = 'width: 100%; height: 100%;overflow: hidden;';
      },
      cancelDialogDrawer() {
        this.visible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      }
    },
    created() {}
  })
</script>

    </div>
    <div class="blog-title" id="author-avatar">
      
        <div class="avatar">
          <img src="/medias/logo.png" class="lazyload placeholder" data-srcset="/medias/logo.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="logo">
        </div>
      
      <a href="/" class="logo">余年的个人博客</a>
    </div>
    <nav class="navbar">
      <ul class="menu">
        
      </ul>
      
      
        <div id="appSearch">
  <div class="search"  @click="showDialog()"><i class="fas fa-search" aria-hidden="true"></i></div>
  <transition name="fade">
    <div class="message-box_wrapper" style="display: none;" v-cloak v-show="dialogVisible" @click.self="cancelDialogVisible()">
      <div class="message-box animated bounceInDown">
        <h2>
          <span>
            <i class="fas fa-search" aria-hidden="true"></i>
            <span class="title">本地搜索</span>
          </span>
          <i class="fas fa-times close" pointer style="float:right;" aria-hidden="true" @click.self="cancelDialogVisible()"></i>
        </h2>
        <form class="site-search-form">
          <input type="text"
            placeholder="请输入关键字"
            id="local-search-input" 
            @click="getSearchFile()"
            class="st-search-input"
            v-model="searchInput"
          />
        </form>
        <div class="result-wrapper">
          <div id="local-search-result" class="local-search-result-cls"></div>
        </div>
      </div>
    </div>
  </transition>
</div>
<script src="/js/local_search.js"></script>
<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appSearch',
    data: {
      dialogVisible: false,
      searchInput: '',
      top: 0,
    },
    computed: {
    },
    mounted() {
      window.addEventListener('pjax:complete', () => {
        this.cancelDialogVisible();
      })
    },
    methods: {
      showDialog() {
        this.dialogVisible = true;
        // 防止页面滚动，只能让弹框滚动
        this.top = $(document).scrollTop()
        body.style.cssText = 'overflow: hidden;';
      },
      getSearchFile() {
        if (!this.searchInput) {
          getSearchFile("/search.xml");
        }
      },
      cancelDialogVisible() {
        this.dialogVisible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      },
    },
    created() {}
  })
</script>
<!-- 解决刷新页面闪烁问题，可以在元素上添加display: none, 或者用vue.extend方法，详情：https://blog.csdn.net/qq_31393401/article/details/81017912 -->
<!-- 下面是搜索基本写法 -->
<!-- <script type="text/javascript" id="local.search.active">
  var inputArea = document.querySelector("#local-search-input");
  inputArea.onclick   = function(){ getSearchFile(); this.onclick = null }
  inputArea.onkeydown = function(){ if(event.keyCode == 13) return false }
</script> -->

      

    </nav>
  </div>
  
    <a href="https://hnuyl16.github.io/" class="github-corner color-primary" aria-label="View source on GitHub"><svg width="60" height="60" viewBox="0 0 250 250" style="fill:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  
  
</header>
        <!-- 内容区域 -->
        
<!-- prismjs 代码高亮 -->

    
    <link href="/js/prism/prism-line-numbers.css" rel="stylesheet">
    <link href="/js/prism/prism.min.css" rel="stylesheet">

    <style>
        pre[class*="language-"] {
            overflow-y: hidden;
        }
        .line-numbers .line-numbers-rows {
            border: none;
        }
    </style>




<div class="bg-dark-floor" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -1;"></div>


  <!-- 文章详情页顶部图片和标题 -->




<div class="post-detail-header" id="thumbnail_canvas" style="background-repeat: no-repeat; background-size: cover; 
  background-position: center center;position: relative;background-image:url('https://picx.zhimg.com/80/v2-85c31120acff76826ab53ea8934ef4bb_1440w.webp')">
  <div class="post-detail-header-mask"></div>
  <canvas id="header_canvas"style="position:absolute;bottom:0;pointer-events:none;"></canvas>
  
  <div class="post-detail-header_info-box">
    <div class="title-box">
      <span class="title">
        MySQL
      </span>
    </div>
    
    
      
        <span class="post-detail-header_date">
          <i class="fas fa-calendar"></i> 发表于：2024-03-03 |
        </span>
      

      
        <span class="post-detail-header_categories">
          <i class="iconfont iconbookmark1"></i> 分类：
          
            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-detail-header_category">
              数据库
            </a>
          
        </span>
      

      
    
  </div>
  
  
    <script defer src="/js/bubble/bubble.js"></script>
  
</div>





<div class="post-detail-content post-row" 
  style="padding-top: 0px;">
  <div class="main-content">
    <article class="post post-detail">
      <div class="post-content">
        <h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>数据库：存储数据的仓库，数据是有组织的进行存储，简称为DataBase(DB)</p>
<p>数据库管理系统：操纵和管理数据库的大型软件，简称为DataBase Management System(DBMS)</p>
<p>SQL：操作关系型数据库的编程语言，定义了一套操作关系型数据库系统统一标准，简称为Structed Query Language(SQL)</p>
<ul>
<li>启动</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start mysql80</span><br></pre></td></tr></table></figure>

<ul>
<li>停止</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net stop mysql80</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端连接</li>
</ul>
<p>方法一：MySQL提供的客户端命令行工具</p>
<p>方法二：系统自带的命令行工具执行指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql [-h 127.0.0.1] [-P 3306] -u root -p</span><br></pre></td></tr></table></figure>

<p>注意：使用第二种方式时，需要配置PATH环境变量</p>
<p><strong>关系型数据库(RDBMS)</strong></p>
<p>概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库</p>
<p>特点：</p>
<ul>
<li>使用表存储数据，格式统一，便于维护</li>
<li>使用SQL语言操作，标准统一，使用方便</li>
</ul>
<p><strong>数据模型</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240229202402534.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240229202402534.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><h4 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h4><ol>
<li>SQL语句可以单行或者多行书写，以分号结尾</li>
<li>SQL语句可以使用空格&#x2F;缩进来增强语句的可读性</li>
<li>MySQL数据库的SQL语句不区分大小写，关键字建议大写</li>
<li>注释：单行注释(–注释内容或# 注释内容(MySQL独有))  多行注释(&#x2F;* 注释内容 *&#x2F;)</li>
</ol>
<p>SQL分类</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>全称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DDL</td>
<td>Data Definnition Language</td>
<td>数据定义语言，用来定义数据库对象(数据库，表，字段)</td>
</tr>
<tr>
<td>DML</td>
<td>Data Manipulation Language</td>
<td>数据操作语言，用来对数据库表中的数据进行增删改</td>
</tr>
<tr>
<td>DQL</td>
<td>Data Query Language</td>
<td>数据查询语言，用来查询数据库表的记录</td>
</tr>
<tr>
<td>DCL</td>
<td>Data Control Language</td>
<td>数据控制语言，用来创建数据库用户，控制数据库的访问权限</td>
</tr>
</tbody></table>
<h4 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h4><p><strong>数据库操作</strong></p>
<p>查询</p>
<ul>
<li>查询所有数据库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询当前数据库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure>

<p>创建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排列规则];</span><br></pre></td></tr></table></figure>

<p>删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Drop DATABASE[IF EXISTS] 数据库名;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure>

<p><strong>表操作</strong></p>
<p>查询当前数据库中所有表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure>

<p>查询表结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC 表名;</span><br></pre></td></tr></table></figure>

<p>查询指定表的建表语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名;</span><br></pre></td></tr></table></figure>

<p>创建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名&#123;</span><br><span class="line">	字段1 字段1类型[COMMENT 字段1注释],</span><br><span class="line">	字段2 字段2类型[COMMENT 字段2注释],</span><br><span class="line">	字段3 字段3类型[COMMENT 字段3注释],</span><br><span class="line">	……</span><br><span class="line">	字段1 字段1类型[COMMENT 字段1注释]</span><br><span class="line">&#125;[COMMENT 表注释];</span><br></pre></td></tr></table></figure>

<p>注意：[…]位&#x3D;为可选参数，最后一个字段后面没有逗号</p>
<p>数据类型</p>
<p>MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。</p>
<p>修改</p>
<ul>
<li>添加字段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</span><br></pre></td></tr></table></figure>

<ul>
<li>修改数据类型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度) </span><br></pre></td></tr></table></figure>

<ul>
<li>修改字段名和字段类型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</span><br></pre></td></tr></table></figure>

<ul>
<li>删除字段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP 字段名;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改表名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 RENAME TO 新表名;</span><br></pre></td></tr></table></figure>

<p>删除</p>
<ul>
<li>删除表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] 表名;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除指定表，并重新创建该表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE 表名;</span><br></pre></td></tr></table></figure>

<p>注意：在删除表时，表中的全部数据也会被删除</p>
<h4 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h4><p>DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进行增删改操作。</p>
<ul>
<li>添加数据 INSERT</li>
<li>修改数据 UPDATE</li>
<li>删除数据 DELETE</li>
</ul>
<p><strong>添加数据</strong></p>
<ul>
<li>给指定字段添加数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名(字段名1,字段名2,...) VALUES(值1,值2,...);</span><br></pre></td></tr></table></figure>

<ul>
<li>给全部字段添加数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 VALUES(值1,值2,...);</span><br></pre></td></tr></table></figure>

<ul>
<li>批量添加数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名(字段名1,字段名2,...) VALUES(值1,值2,...),(值1,值2,...),(值1,值2,...);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 VALUES(值1,值2,...),(值1,值2,...),(值1,值2,...);</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>插入数据时，指定的字段顺序需要与值得顺序是一一对应的</li>
<li>字符串和日期型数据应该包含在引号中</li>
<li>插入的数据大小，应该在字段的规定范围内</li>
</ul>
<p><strong>修改数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE 表名 SET 字段1 = 值1 ,字段2 = 值2, ...[WHERE 条件];</span><br></pre></td></tr></table></figure>

<p>注意：修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据</p>
<p>删除数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 表名 [WHERE 条件];</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>DELETE语句的条件可以有，也可以没有，如果没有条件，则会删除所有整张表的所有数据</li>
<li>DELETE语句不能删除某一个字段的值(可以使用UPDATE)</li>
</ul>
<h4 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h4><p>DQL全称是Data Query Lanuage(数据查询语言)，数据查询语言，用来查询数据库表的记录</p>
<p>查询关键字：<mark>SELECT</mark></p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	字段列表</span><br><span class="line">FROM</span><br><span class="line">	表名列表</span><br><span class="line">WHERE</span><br><span class="line">	条件列表</span><br><span class="line">GROUP BY</span><br><span class="line">	分组字段列表</span><br><span class="line">HAVING</span><br><span class="line">	分组后条件列表</span><br><span class="line">ORDER BY</span><br><span class="line">	排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">    分页参数</span><br></pre></td></tr></table></figure>

<p><strong>基础查询</strong></p>
<ul>
<li>查询多个字段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段1,字段2,字段3... FROM 表名;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表名;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置别名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段1 [AS 别名1], 字段2 [AS 别名2] ... FROM 表名;</span><br></pre></td></tr></table></figure>

<ul>
<li>去除重复记录</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT 字段列表 FROM 表名;</span><br></pre></td></tr></table></figure>

<p><strong>条件查询</strong></p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 WHERE 条件列表;</span><br></pre></td></tr></table></figure>

<p>条件</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt;或！&#x3D;</td>
<td>不等于</td>
</tr>
<tr>
<td>BETWEEN… AND…</td>
<td>在某个范围之内(含最小、最大值)</td>
</tr>
<tr>
<td>IN(…)</td>
<td>在in之后的列表中的值，多选一</td>
</tr>
<tr>
<td>LIKE 占位符</td>
<td>模糊匹配(_匹配单个字符，%匹配任意字符)</td>
</tr>
<tr>
<td>IS NULL</td>
<td>是NULL</td>
</tr>
<tr>
<td>AND 或  &amp;&amp;</td>
<td>并且(多个条件同时成立时)</td>
</tr>
<tr>
<td>OR 或  ||</td>
<td>或者(多个条件任意一个成立时)</td>
</tr>
<tr>
<td>NOT 或  !</td>
<td>非，不是</td>
</tr>
</tbody></table>
<p><strong>聚合函数</strong></p>
<p>将一列数据作为一个整体，进行纵向计算</p>
<p>常见聚合函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>count</td>
<td>统计数量</td>
</tr>
<tr>
<td>max</td>
<td>最大值</td>
</tr>
<tr>
<td>min</td>
<td>最小值</td>
</tr>
<tr>
<td>avg</td>
<td>平均值</td>
</tr>
<tr>
<td>sum</td>
<td>求和</td>
</tr>
</tbody></table>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 聚合函数 (字段列表) FROM 表名;</span><br></pre></td></tr></table></figure>

<p>注意：所有null值不参与所有聚合函数运算</p>
<p><strong>分组查询</strong></p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 [where 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];</span><br></pre></td></tr></table></figure>

<p>where和having区别</p>
<ul>
<li>执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤</li>
<li>判断条件不同：where不能对聚合函数进行判断，而having可以</li>
</ul>
<p>注意</p>
<ul>
<li>执行顺序：where &gt; 聚合函数 &gt; having</li>
<li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段五任何意义</li>
</ul>
<p><strong>排序查询</strong></p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;</span><br></pre></td></tr></table></figure>

<p>排序方式</p>
<ul>
<li>ASC：升序(默认值)</li>
<li>DESC：降序</li>
</ul>
<p>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</p>
<p><strong>分页查询</strong></p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;</span><br></pre></td></tr></table></figure>

<p>注意</p>
<ul>
<li>起始索引从0开始，起始索引 &#x3D; (查询页码 - 1) *每页记录数</li>
<li>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL是LIMIT</li>
<li>如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10</li>
</ul>
<p><strong>执行顺序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM</span><br><span class="line">	表名列表</span><br><span class="line">WHERE</span><br><span class="line">	条件列表</span><br><span class="line">GROUP BY</span><br><span class="line">	分组字段列表</span><br><span class="line">HAVING</span><br><span class="line">	分组后条件列表</span><br><span class="line">SELECT</span><br><span class="line">	字段列表</span><br><span class="line">ORDER BY</span><br><span class="line">	排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">    分页参数</span><br></pre></td></tr></table></figure>

<h4 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h4><p>DCL全称是Data Control Language(数据库控制语言)，用来管理数据库用户、控制数据库的访问权限</p>
<p><strong>管理用户</strong></p>
<ul>
<li>查询用户</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line">SELECT * FROM USER;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建用户</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改用户密码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除用户</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>

<p>注意</p>
<ul>
<li>主机名可以使用%适配</li>
<li>这类SQL开发人员操作的比较少，主要是DBA(Data Administrator 数据库管理员)使用</li>
</ul>
<p><strong>权限控制</strong></p>
<p>MySQL中定义了很多权限，但是常见的就以下几种：</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ALL，ALL PRIVILEGES</td>
<td>所有权限</td>
</tr>
<tr>
<td>SELECT</td>
<td>查询数据</td>
</tr>
<tr>
<td>INSERT</td>
<td>插入数据</td>
</tr>
<tr>
<td>UPDATE</td>
<td>修改数据</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除数据</td>
</tr>
<tr>
<td>ALTER</td>
<td>修改表</td>
</tr>
<tr>
<td>DROP</td>
<td>删除数据库&#x2F;表&#x2F;视图</td>
</tr>
<tr>
<td>CREATE</td>
<td>创建数据库&#x2F;表</td>
</tr>
</tbody></table>
<ul>
<li>查询权限</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>授予权限</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANTS 权限列表 ON 数据库名.表名 TO &#x27;用户名&#x27;@&#x27;主机&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>撤销权限</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@&#x27;主机&#x27;;</span><br></pre></td></tr></table></figure>

<p>注意</p>
<ul>
<li>多个权限之间，使用逗号分隔</li>
<li>授权时，数据库名和表名可以使用*进行通配，代表所有</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数 是指一段能够可以直接被另一段程序调用的程序或者代码</p>
<p><strong>字符串函数</strong></p>
<p>MySQL中内置了很多字符串函数，常用的几个如下：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>CONCAT(S1,S2,…Sn)</td>
<td>字符串拼接，将S1、S2、…Sn拼接成一个字符串</td>
</tr>
<tr>
<td>LOWER(str)</td>
<td>将字符串str全部转化为小写字母</td>
</tr>
<tr>
<td>UPPER(str)</td>
<td>将字符串str全部转化为大写字母</td>
</tr>
<tr>
<td>LPAD(str,n,pad)</td>
<td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td>RPAD(sre,n,pad)</td>
<td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td>TRIM(str)</td>
<td>去掉字符串头部和尾部的空格</td>
</tr>
<tr>
<td>SUBSTRING(str,start,len)</td>
<td>返回从字符串start位置起的len个长度的字符串(索引从1开始)</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 函数(参数);</span><br></pre></td></tr></table></figure>

<p><strong>数值函数</strong></p>
<p>常见的数值函数如下：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>CEIL(x)</td>
<td>向上取整</td>
</tr>
<tr>
<td>FLOOR(x)</td>
<td>向下取整</td>
</tr>
<tr>
<td>MOD(x,y)</td>
<td>返回x&#x2F;y的模</td>
</tr>
<tr>
<td>RAND()</td>
<td>返回0~1之内的随机数</td>
</tr>
<tr>
<td>ROUND(x,y)</td>
<td>求参数x的四舍五入的值，保留y位小数</td>
</tr>
</tbody></table>
<p><strong>日期函数</strong></p>
<p>常见的日期函数如下：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>CURDATE()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CURTIME()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>NOW()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>YEAR(date)</td>
<td>获取指定date的年份</td>
</tr>
<tr>
<td>MONTH(date)</td>
<td>获取指定date的月份</td>
</tr>
<tr>
<td>DAY(date)</td>
<td>获取指定date的日期</td>
</tr>
<tr>
<td>DATE_ADD(date，INTERVAL expr type)</td>
<td>返回上一个日期&#x2F;时间值加上一个时间间隔expr后的时间值</td>
</tr>
<tr>
<td>DATEDIFF(date1，date2)</td>
<td>返回起始时间date1和结束时间date2之间的天数</td>
</tr>
</tbody></table>
<p><strong>流程函数</strong></p>
<p>流程函数也是很常用的一类函数，可以在SQL语句中实现条件筛选，从而提高语句的效率</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>IF(value,t,f)</td>
<td>如果value为true，则返回t，否则返回f</td>
</tr>
<tr>
<td>IFNULL(value1,value2)</td>
<td>如果value不为空，返回value1，否则返回value2</td>
</tr>
<tr>
<td>CASE WHEN [val1] THEN [res1] … ELSE [default] END</td>
<td>如果val1为true，返回res1，…否则返回default默认值</td>
</tr>
<tr>
<td>CASE [expr] WHEN [val1] THEN [res1] … ELSE [default] END</td>
<td>如果expr的值等于val1，返回res1，…否则返回default默认值</td>
</tr>
</tbody></table>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。</p>
<p>目的：保证数据库中数据的正确，有效性和完整性</p>
<p>分类：</p>
<table>
<thead>
<tr>
<th>约束</th>
<th>描述</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>非空约束</td>
<td>限制该字段的数据不能为null</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>唯一约束</td>
<td>保证该字段的所有数据都是唯一的，不重复的</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>主键约束</td>
<td>主键是一行数据的唯一标识，要求非空且唯一</td>
<td>PRIMARY KEY</td>
</tr>
<tr>
<td>默认约束</td>
<td>保存数据时，如果未指定该字段的值，则采用默认值</td>
<td>DEFAULT</td>
</tr>
<tr>
<td>检查约束(8.0.16版本之后)</td>
<td>保证字段值满足某一个条件</td>
<td>CHECK</td>
</tr>
<tr>
<td>外键约束</td>
<td>用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td>
<td>FOREIGN KEY</td>
</tr>
</tbody></table>
<p>注意：约束是作用于表中字段上的，可以在创建表&#x2F;修改表的时候添加约束，主键自增(auto -increment)</p>
<h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><p>语法</p>
<ul>
<li>添加外键</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	字段名  数据类型,</span><br><span class="line">    ...</span><br><span class="line">    [CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);</span><br></pre></td></tr></table></figure>

<ul>
<li>删除外键</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除&#x2F;更新行为</li>
</ul>
<table>
<thead>
<tr>
<th>行为</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NO ACTION</td>
<td>当在父表中删除&#x2F;更新记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新</td>
</tr>
<tr>
<td>RESTRICT</td>
<td>当在父表中删除&#x2F;更新记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新</td>
</tr>
<tr>
<td>CASCADE</td>
<td>当在父表中删除&#x2F;更新记录时，首先检查该记录是否有对应外键，如果有，则也删除&#x2F;更新外键在子表中的记录</td>
</tr>
<tr>
<td>SET NULL</td>
<td>当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有，则设置子表中该外键值为null(这就要求该外键允许取null)</td>
</tr>
<tr>
<td>SET DEFAULT</td>
<td>父表有变更时，子表将外键列设置成一个默认的值(Innodb不支持)</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;</span><br></pre></td></tr></table></figure>

<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三类：一对多(多对一)、多对多、一对一</p>
<h4 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h4><ul>
<li>一对多(多对一)</li>
</ul>
<p>案例：部门与员工之间的关系</p>
<p>关系：一个部门对应多个员工，多个员工对应一个部门</p>
<p>实现：在多的一方建立外键，指向一的一方建立主键</p>
<ul>
<li>多对多</li>
</ul>
<p>案例：学生与课程之间的关系</p>
<p>关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择</p>
<p>实现：建立第三张中间表，中间至少包含两个外键，分别关联两方主键</p>
<ul>
<li>一对一</li>
</ul>
<p>案例：用户与用户详情的关系</p>
<p>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率</p>
<p>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</p>
<p>多表查询分类</p>
<ul>
<li>连接查询<ul>
<li>内连接：相当于查询A、B交集部分数据</li>
<li>外连接：<ul>
<li>左外连接：查询<strong>左表</strong>所有数据，以及两张表交集部分数据</li>
<li>右外连接：查询<strong>右表</strong>所有数据，以及两张表交集部分数据</li>
</ul>
</li>
<li>自连接：当前表与自身的连接查询，自连接必须使用表别名</li>
</ul>
</li>
<li>子查询</li>
</ul>
<h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><p><strong>内连接</strong></p>
<p>查询语法</p>
<ul>
<li>隐式内连接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1，表2 WHERE 条件 ...;</span><br></pre></td></tr></table></figure>

<ul>
<li>显式内连接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件 ...;</span><br></pre></td></tr></table></figure>

<p>内连接查询的是两张表<strong>交集</strong>的部分</p>
<p><img src="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240303115658392.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240303115658392.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><strong>外连接</strong></p>
<p>查询语法</p>
<ul>
<li>左外连接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件 ...;</span><br></pre></td></tr></table></figure>

<p>相当于查询表1(左表)的所有数据 包含表1和表2交集部分的数据</p>
<ul>
<li>右外连接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件 ...;</span><br></pre></td></tr></table></figure>

<p>相当于查询表2(右表)的所有数据 包含表1和表2交集部分的数据</p>
<p><strong>自连接</strong></p>
<p>查询语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;</span><br></pre></td></tr></table></figure>

<p>自连接查询，可以是内连接查询，也可以是外连接查询</p>
<p>注意：在自连接查询时，必须要为表起别名，要不然我们不清楚所指定的条件、返回的字段，到底是哪一张表的字段</p>
<p><strong>联合查询-union，union all</strong></p>
<p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A ...</span><br><span class="line">UNION [ALL]</span><br><span class="line">SELECT 字段列表 FROM 表B ...;</span><br></pre></td></tr></table></figure>

<p>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致</p>
<p>union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重</p>
<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>概念：SQL语句中嵌套SELECT语句，称为<strong>嵌套查询</strong>，又称<strong>子查询</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 where column1 = (SELECT column1 FROM t2);</span><br></pre></td></tr></table></figure>

<p>子查询外部的语句可以是INSERT &#x2F; UPDATE &#x2F; DELETE SELECT 的任何一个</p>
<p>根据子查询结果不同，分为以下四类：</p>
<ul>
<li>标量子查询(子查询的结果为单个值)</li>
<li>列子查询(查询结果为一列)</li>
<li>行子查询(查询结果为一行)</li>
<li>表子查询(子查询结果为多行多列)</li>
</ul>
<p>根据子查询位置：分为：WHERE之后、FROM之前、SELECT之后</p>
<p><strong>标量子查询</strong></p>
<p>子查询返回的结果是单个值(数字、字符串、日期等)，最简单的形式</p>
<p>常用的操作符：&#x3D;  &lt;&gt; &gt;&#x3D; &gt;  &lt;&#x3D;  &lt;</p>
<p><strong>列子查询</strong></p>
<p>子查询返回的结果是一列(可以是多行)</p>
<p>常用的操作符：IN、NOT IN、ANY、SOME、ALL</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>IN</td>
<td>在指定的集合范围之内，多选一</td>
</tr>
<tr>
<td>NOT IN</td>
<td>不在指定集合范围内</td>
</tr>
<tr>
<td>ANY</td>
<td>子查询返回列表中，有任意一个条件满足即可</td>
</tr>
<tr>
<td>SOME</td>
<td>与ANY等同，使用SOME的地方都可以使用ANY</td>
</tr>
<tr>
<td>ALL</td>
<td>子查询返回列表的所有值都必须满足</td>
</tr>
</tbody></table>
<p><strong>行子查询</strong></p>
<p>子查询返回的结果是一行(可以是多列)</p>
<p>常用</p>
<p>的操作符：&#x3D;、&lt;&gt;、IN、NOT IN</p>
<p><strong>表子查询</strong></p>
<p>子查询返回的结果是多行多列</p>
<p>常用的操作符：IN</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功、要么同时失败</p>
<p>默认MySQL的事务是自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式的提交事务</p>
<h4 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h4><p>方式一</p>
<ul>
<li>查看 &#x2F; 设置事务提交方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@autocommit;</span><br><span class="line">SET @@autocommit = 0;	//关闭自动提交</span><br></pre></td></tr></table></figure>

<ul>
<li>提交事务</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<ul>
<li>回滚事务</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>

<p>方式二</p>
<ul>
<li>开始事务</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION 或 BEGIN;	//开始事务</span><br></pre></td></tr></table></figure>

<ul>
<li>提交事务</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<ul>
<li>回滚事务</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>

<h4 id="事务四大特性-ACID"><a href="#事务四大特性-ACID" class="headerlink" title="事务四大特性(ACID)"></a>事务四大特性(ACID)</h4><p>原子性(Atomicty)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</p>
<p>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</p>
<p>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响下的独立环境下运行</p>
<p>持久性(Durability)：事务一旦提交或者回滚，它对数据库中的数据的改变就是永久的</p>
<h4 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h4><table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>脏读</strong></td>
<td>一个事务读到另一个事务还没有提交的数据</td>
</tr>
<tr>
<td><strong>不可重复读</strong></td>
<td>一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读</td>
</tr>
<tr>
<td><strong>幻读</strong></td>
<td>一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了”幻影”</td>
</tr>
</tbody></table>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Read uncommitted</strong></td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td><strong>Read committed</strong></td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td><strong>Repeatable Read(默认)</strong></td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td><strong>Serializable</strong></td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查看事务隔离级别</span><br><span class="line">SELECT @@TRANSACTION_ISOLATION;</span><br><span class="line"></span><br><span class="line">-- 设置事务隔离级别</span><br><span class="line">SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | RED COMMITTED | REPEATABLE READ | SERIALIZABLE&#125;</span><br></pre></td></tr></table></figure>

<p>注意：事务的隔离级别越高，数据越安全，但是性能越低</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><h4 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h4><ul>
<li><strong>连接层</strong></li>
</ul>
<p>最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限</p>
<ul>
<li><strong>服务层</strong></li>
</ul>
<p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析与优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等</p>
<ul>
<li><strong>引擎层</strong></li>
</ul>
<p>存储引擎真正地负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选择合适的引擎</p>
<ul>
<li><strong>存储层</strong></li>
</ul>
<p>主要是将数据存储在文件系统之上，并完成与存储引擎的交互</p>
<h4 id="存储引擎-1"><a href="#存储引擎-1" class="headerlink" title="存储引擎"></a>存储引擎</h4><p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型</p>
<ul>
<li>在创建表时，指定存储引擎</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	字段1 字段1类型 [COMMENT 字段1注释],</span><br><span class="line">    ...</span><br><span class="line">    字段n 字段n类型 [COMMENT 字段n注释]</span><br><span class="line">) ENGINE = INNODB [COMMENT 表注释];</span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前数据库支持的存储引擎</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW ENGINES;</span><br></pre></td></tr></table></figure>

<p><strong>InnoDB</strong></p>
<p>InnoDB是一种兼顾可靠性和高性能的通用存储引擎，在MySQL5.5之后，InnoDB是默认的MySQL存储引擎</p>
<p>特点</p>
<ul>
<li>DML操作支持ACID模型，支持事务；</li>
<li>行级锁，提高并发访问性能；</li>
<li>支持外键FOREIGN KEY 约束，保证数据的完整性和正确性</li>
</ul>
<p>文件</p>
<ul>
<li>xxx.ibd：xxx代表的是表名，InnoDB引擎的每一张表都会对应这样的一个表空间文件，存储该表的表结构(frm、sdi)、数据和索引</li>
<li>参数：innodb_file_per_table</li>
</ul>
<p>存储结构</p>
<p><img src="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240305190759951.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240305190759951.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><strong>MyISAM</strong></p>
<p>MyISAM是MySQL早期的默认存储引擎</p>
<p>特点</p>
<ul>
<li>不支持事务，不支持外键</li>
<li>支持表锁，不支持行锁</li>
<li>访问速度快</li>
</ul>
<p>文件</p>
<ul>
<li>xxx.sdi：存储表结构信息</li>
<li>xxx.MYD：存储数据</li>
<li>xxx.MYI：存储索引</li>
</ul>
<p><strong>Memory</strong></p>
<p>Memory引擎的表数据是存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用</p>
<p>特点</p>
<ul>
<li>内存存放</li>
<li>hash索引(默认)</li>
</ul>
<p>文件</p>
<ul>
<li>xxx.sdi：存储表结构信息</li>
</ul>
<p><strong>区别</strong></p>
<table>
<thead>
<tr>
<th>特点</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>64TB</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>事务安全</td>
<td><strong>支持</strong></td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>锁机制</td>
<td><strong>行锁</strong></td>
<td>表锁</td>
<td>表锁</td>
</tr>
<tr>
<td>B+tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash索引</td>
<td>-</td>
<td>-</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持(5.6版本之后)</td>
<td>支持</td>
<td>-</td>
</tr>
<tr>
<td>空间使用</td>
<td>高</td>
<td>低</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>内存使用</td>
<td>高</td>
<td>低</td>
<td>中等</td>
</tr>
<tr>
<td>批量插入速度</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>支持外键</td>
<td><strong>支持</strong></td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p><strong>存储引擎选择</strong></p>
<p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎，对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合</p>
<ul>
<li>InnoDB：是MySQL的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件上要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较适合的xuanz</li>
<li>MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求并不是很高，那么选择这个存储引擎是非常合适的</li>
<li>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li>
</ul>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>索引(inedx)是帮助MySQL<strong>高效获取数据</strong>的**数据结构(有序)**。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现查找算法，这种数据结构就是索引。</p>
<ul>
<li>优缺点</li>
</ul>
<table>
<thead>
<tr>
<th>优势</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>提高数据检索的效率，降低数据库的IO成本</td>
<td>索引列也是要占用内存空间的</td>
</tr>
<tr>
<td>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</td>
<td>索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率很低</td>
</tr>
</tbody></table>
<h4 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h4><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下内容：</p>
<table>
<thead>
<tr>
<th>索引结构</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>B+ Tree索引</strong></td>
<td><strong>最常见的索引类型，大部分引擎都支持B+ 树索引</strong></td>
</tr>
<tr>
<td>Hash 索引</td>
<td>底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询</td>
</tr>
<tr>
<td>R- tree (空间索引)</td>
<td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td>
</tr>
<tr>
<td>Full-text (全文索引)</td>
<td>是一种通过建立倒排索引，快速匹配文档的方式。类似于Lucence,Solr，ES</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>MEMORY</th>
</tr>
</thead>
<tbody><tr>
<td>B+ tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash 索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R- tree索引</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text索引</td>
<td>5.6版本后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<p><strong>B-tree(多路平衡查找树)</strong></p>
<p>以一颗最大度数为5(5阶)的b-tree为例(每个节点最多存储4个key，5个指针)：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240306203048434.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240306203048434.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><strong>B+Tree</strong></p>
<p>以一颗最大度数为4的b+tree为例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240306203715175.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240306203715175.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>相比较B-Tree的区别：</p>
<ul>
<li>所有的数据都会出现在要叶子结点</li>
<li>叶子结点形成一个单向链表</li>
</ul>
<p>MySQL的索引数据结构对经典的B+Tree进行了优化，在原B+Tree的基础上，增加了一个指向相邻叶子结点的链表指针，就形成了带有顺序指针的B+Tree，提高了区间访问的性能，利于排序</p>
<p><img src="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240306204334741.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240306204334741.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><strong>Hash</strong></p>
<p>哈希索引就是采用一定的哈希算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中</p>
<p>如果两个或多个键值，映射到一个相同的槽位上时，他们就产生了hash冲突(也称为hash碰撞)，可以通过链表来解决</p>
<p>索引特点</p>
<ul>
<li>hash索引只能用于对等比较(&#x3D;，in)，不支持范围查询(between，&gt;，&lt;，…)</li>
<li>无法利于索引完成排序操作</li>
<li>查询效率高，通常只需要一次检索就可以了，效率通常要高于B+Tree索引</li>
</ul>
<p>在MySQL中，支持hash索引的是Memory引擎，而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的</p>
<h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引</td>
<td>针对表中主键创建的索引</td>
<td>默认自动创建，只能有一个</td>
<td>PRIMARY</td>
</tr>
<tr>
<td>唯一索引</td>
<td>避免同一个表中某数据列中的值重复</td>
<td>可以有多个</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>常规索引</td>
<td>快速定位特定数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td>
<td>可以有多个</td>
<td>FULLTEXT</td>
</tr>
</tbody></table>
<p>在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>聚集索引(Clustered Index)</td>
<td>将数据存储和索引放到了一块，索引结构的叶子结点保存了行数据</td>
<td>必须有，而且只有一个</td>
</tr>
<tr>
<td>二级索引(Secondary Index)</td>
<td>将数据和索引分开存储，索引结构的叶子结点关联的是对应的主键</td>
<td>可以存在多个</td>
</tr>
</tbody></table>
<p>聚集索引选取规则：</p>
<ul>
<li>如果存在主键，主键索引就是聚集索引</li>
<li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li>
<li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li>
</ul>
<h4 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h4><ul>
<li>创建索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE | FULLTEXT] INDEX index_name on table_name (index_col,name,...);</span><br></pre></td></tr></table></figure>

<ul>
<li>查看索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM table_name;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure>

<h4 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h4><ul>
<li>SQL执行频率</li>
</ul>
<p>MySQL客户端连接成功后，通过show[session|global] status命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE &#x27;COM_____&#x27;;  -- 一个下划线代表一个字符</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>慢查询日志</strong></li>
</ul>
<p>慢查询日志记录了所有执行时间超过指定参数(long_query_time，单位：秒，默认10秒)的所有SQL语句的日志</p>
<p>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件(&#x2F;etc&#x2F;my.cnf)中配置如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 开启MySQL慢日志查询开关</span><br><span class="line">slow_query_log = 1</span><br><span class="line"># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span><br><span class="line">long_query_time = 2</span><br></pre></td></tr></table></figure>

<p>配置完毕后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-slow.log</p>
<ul>
<li><strong>profile详情</strong></li>
</ul>
<p>show profiles能够在做SQL优化时帮助我们了解时间都耗费到哪里去了，通过have_profiling参数，能够看到当前MySQL是否支持profile操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@have_profiling;</span><br></pre></td></tr></table></figure>

<p>默认profiling是关闭的，可以通过set语句在session &#x2F; global级别开启profiling：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@profiling; -- 查询是否开始</span><br><span class="line">SET profiling = 1;</span><br></pre></td></tr></table></figure>

<p>执行一系列的业务SQL操作，然后通过以下指令查看指令的执行耗时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查看每一条SQL的耗时基本情况</span><br><span class="line">show profiles;</span><br><span class="line"># 查看指定query_id的SQL语句各个阶段的耗时情况</span><br><span class="line">show profile for query query_id;</span><br><span class="line"># 查看指定query_id的SQL语句CPU的使用情况</span><br><span class="line">show profile cpu for query query_id;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>explain执行计划</strong></li>
</ul>
<p>EXPLAIN或者DESC命令获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 直接在select语句前加上关键字explain / desc</span><br><span class="line">EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;</span><br></pre></td></tr></table></figure>

<p>EXPLAIN执行计划各字段含义：</p>
<ul>
<li>id</li>
</ul>
<p>select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)</p>
<ul>
<li>select_type</li>
</ul>
<p>表示SELECT的类型，常见的取值有SIMPLE(简单表，即不能使用表连接或者子查询)、PRIMARY(主查询，即外层的查询)、UNION(UNION中的第二个或者后面的查询语句)、SUBQUERY(SELECT&#x2F;WHERE之后包含了子查询等)</p>
<ul>
<li><strong>type</strong></li>
</ul>
<p>表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all</p>
<ul>
<li>possible_key</li>
</ul>
<p>显示可能应用在这张表上的索引，一个或者多个</p>
<ul>
<li>key</li>
</ul>
<p>实际使用的索引，如果为NULL，则没有使用索引</p>
<ul>
<li>key_len</li>
</ul>
<p>表示索引中使用的字节数，该值为索引字段的最大可能长度，并非实际长度，在不损失精确性的前提下，长度越短越好</p>
<ul>
<li>rows</li>
</ul>
<p>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并总是准确的</p>
<ul>
<li>filtered</li>
</ul>
<p>表示返回结果的行数占需读取行数的百分比，filtered的值越大越好</p>
<h4 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h4><ul>
<li>验证索引效率</li>
</ul>
<p>在未建立索引之前，执行如下SQL语句，查看SQL的耗时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tb_sku WHERE sn = &#x27;1000000000314001&#x27;;</span><br></pre></td></tr></table></figure>

<p>针对字段创建索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index idx_sku_sn on tb_sku(sn);</span><br></pre></td></tr></table></figure>

<p>然后再次执行相同的SQL语句，再次查看SQL的耗时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tb_sku WHERE sn = &#x27;1000000000314001&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>最左前缀法则</strong></p>
<p>如果索引了多列(联合索引)，要遵循最左前缀法则。最左前缀法则指的是查询从索引的<mark>最左列开始</mark>，并且不跳过索引中的列。如果跳跃了某一列，<mark>索引将部分失效(后面的字段索引失效)</mark></p>
<p><strong>索引失效情况</strong></p>
<ul>
<li>索引列运算</li>
</ul>
<p>不要在索引列上进行运算操作，索引将失效</p>
<ul>
<li>模糊查询</li>
</ul>
<p>如果仅仅是尾部模糊查询，索引将不会失效；如果是头部模糊查询，索引将会失效</p>
<ul>
<li>or连接的条件</li>
</ul>
<p>用or分割开的条件，如果or前的条件中的列有索引，而后面的列没有索引，那么涉及的索引都不会被使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_user where id = 10 or age = 20;</span><br><span class="line">explain select * from tb_user where phone = &#x27;17799990017&#x27; or age = 23;</span><br></pre></td></tr></table></figure>

<p>由于age没有索引，所以即使id、phone有索引，索引也会失效。所以需要针对age也要建立索引</p>
<ul>
<li>数据分布影响</li>
</ul>
<p>如果MySQL评估使用索引比全表更慢，则不会使用索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_user where phone&gt;=&#x27;17799990005&#x27;;</span><br><span class="line">select * from tb_user where phone&gt;=&#x27;17799990015&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>SQL提示</strong></p>
<p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的</p>
<p><code>use index</code>(建议使用该索引)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_user use index(idx_user_pro) where profession = &#x27;软件工程&#x27;;</span><br></pre></td></tr></table></figure>

<p><code>ignore index</code>(忽略使用此索引)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_user ignore index(idx_user_pro) where profession = &#x27;软件工程&#x27;;</span><br></pre></td></tr></table></figure>

<p><code>force index</code>(强制使用该索引)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_user force index(idx_user_pro) where profession = &#x27;软件工程&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>覆盖索引</strong></p>
<p>尽量使用覆盖索引(查询使用了索引，并且需要返回的列，在该索引中已经能够全部找到)，减少select *；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_user where profession = &#x27;软件工程&#x27; and age = 31 and status = &#x27;0&#x27;;</span><br><span class="line">explain select id,profession from tb_user where profession = &#x27;软件工程&#x27; and age = 31 and status = &#x27;0&#x27;;</span><br><span class="line">explain select id,profession,age from tb_user where profession = &#x27;软件工程&#x27; and age = 31 and status = &#x27;0&#x27;;</span><br><span class="line">explain select id,profession,age,status from tb_user where profession = &#x27;软件工程&#x27; and age = 31 and status = &#x27;0&#x27;;</span><br><span class="line">explain select id,profession,age,status,name from tb_user where profession = &#x27;软件工程&#x27; and age = 31 and status = &#x27;0&#x27;;</span><br></pre></td></tr></table></figure>

<p><code>using index condition</code>：查找使用了索引，但是需要回表查询数据</p>
<p><code>using where;using index</code>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</p>
<p><strong>前缀索引</strong></p>
<p>当字段类型为字符串(varchar、text等)时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率</p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index idx_xxx on table_name(column(n));	//n代表字符串的前n个字符</span><br></pre></td></tr></table></figure>

<p>前缀长度</p>
<p>可以根据索引的选择性来决定，而选择性是指不重复的索引值(基数)和数据表的记录总数比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct email)/ count(*) from tb_user;</span><br><span class="line">select count(distinct substring(email,1,5)) / count(*) from tb_user;</span><br></pre></td></tr></table></figure>

<p><strong>单列索引与联合索引</strong></p>
<p>单列索引：即一个索引只包含单个列</p>
<p>联合索引：即一个索引包含了多个列</p>
<p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建立联合索引，而非单列索引</p>
<p>单列索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select id,phone,name from tb_user where phone = &#x27;17799990010&#x27; and name = &#x27;韩信&#x27;;</span><br></pre></td></tr></table></figure>

<p><mark>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询</mark></p>
<p>联合索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create unique index idx_phone_name on tb_user(phone,name);</span><br></pre></td></tr></table></figure>

<p><strong>索引设计原则</strong></p>
<ul>
<li>针对于数据量比较大，且查询比较频繁的表建立索引</li>
<li>针对于常作为查询条件(where)、排序(order by)、分组(group by)操作的字段建立索引</li>
<li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li>
<li>如果是字符串类型的字段，字段的长度较长，可以针对字符串的特点，建立前缀索引</li>
<li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li>
<li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率</li>
<li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它，当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引更有效地用于查询</li>
</ul>
<h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><p><strong>insert优化</strong></p>
<ul>
<li>批量插入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into tb_test values(1,&#x27;Tom&#x27;),(2,&#x27;Cat&#x27;),(3,&#x27;Jerry&#x27;);</span><br></pre></td></tr></table></figure>

<ul>
<li>手动事务提交</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">insert into tb_test values(1,&#x27;Tom&#x27;),(2,&#x27;Cat&#x27;),(3,&#x27;Jerry&#x27;);</span><br><span class="line">insert into tb_test values(4,&#x27;Tom&#x27;),(5,&#x27;Cat&#x27;),(6,&#x27;Jerry&#x27;);</span><br><span class="line">insert into tb_test values(7,&#x27;Tom&#x27;),(8,&#x27;Cat&#x27;),(9,&#x27;Jerry&#x27;);</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<ul>
<li>主键插入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 主键乱序插入：8 1 9 21 80 2 4 15 89 5 7 3</span><br><span class="line">-- 主键顺序插入：1 2 3 4 5 6 7 8 9 15 21 88 89</span><br></pre></td></tr></table></figure>

<p><strong>大量批量插入数据</strong></p>
<p>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 客户端连接服务器时，还需要加上参数 --local-infile</span><br><span class="line">mysql --local-infile -u root -p</span><br><span class="line"># 设置全局参数local_infile为1，开始从本地加载文件导入数据的开关</span><br><span class="line">set global local_infile = 1;</span><br><span class="line"># 执行load指令将准备好的数据，加载到表结构中</span><br><span class="line">load data local infile &#x27;/root/sql1.log&#x27; into table `tb_user` fileds terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;;</span><br></pre></td></tr></table></figure>

<p><mark>主键顺序插入性能高于乱序插入</mark></p>
<h4 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h4><ul>
<li>数据组织方式</li>
</ul>
<p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为<mark>索引组织表</mark>(index organized table <strong>IOT</strong>)</p>
<ul>
<li>页分裂</li>
</ul>
<p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，就会行溢出)，根据主键排列如果主键是乱序插入，会扰乱原来已排序好的页，MySQL 会通过新建页并调整原来已经存放在页中的数据来达到维护主键有序的效果，这便是<strong>页分裂</strong>。</p>
<ul>
<li>页合并</li>
</ul>
<p>当删除某一行记录时，实际上记录并没有被物理删除，只是记录被被标记(flaged)为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录达到MERGE_THRESHOLD(默认为页的50%)，InnoDB会开始寻找最靠近的页(前或后)看看是否可以将两个页合并以优化空间使用,此之谓<strong>页合并</strong>。</p>
<p><code>MERGE_THRESHOLD</code>：合并页的阈值，可以自己设置，在创建表或者索引的时候指定</p>
<p><strong>主键设计原则</strong></p>
<ol>
<li><p>满足业务需求条件下，尽量降低主键长度</p>
</li>
<li><p>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键</p>
</li>
<li><p>尽量不要使用UUID做主键或者其他自然主键，如身份证号</p>
</li>
<li><p>业务操作时，避免对主键的修改</p>
</li>
</ol>
<h4 id="order-by-优化"><a href="#order-by-优化" class="headerlink" title="order by 优化"></a>order by 优化</h4><ol>
<li><code>Using filesort</code>：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都是FileSort排序</li>
<li><code>Using index</code>：通过有序索引顺序扫描直接返回有序结果，这种情况即为Using index，不需要额外排序，操作效率高</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 没有创建索引时，根据age,phone进行排序</span><br><span class="line">explain select id,age,phone from tb_user order by age, phone;</span><br><span class="line"># 创建索引</span><br><span class="line">create index idx_user_age_phone_aa on tb_user(age,phone);</span><br><span class="line"># 创建索引成功后，根据age、phone进行升序排序</span><br><span class="line">explain select id,age,phone from tb_user order by age, phone;</span><br><span class="line"># 创建索引成功后，根据age、phone进行降序排序</span><br><span class="line">explain select id,age,phone from tb_user order by age desc, phone desc;</span><br><span class="line"># 根据age升序、phone降序排序</span><br><span class="line">explain select id,age,phone from tb_user order by age asc, phone desc;</span><br><span class="line"># 创建索引</span><br><span class="line">create index idx_age_phone_ad on tb_user(age asc,phone desc);</span><br><span class="line"># 创建索引后，根据age、phone进行升序排序</span><br><span class="line">explain select id,age,phone from tb_user order by age, phone;</span><br><span class="line"># 创建索引成功后，根据age、phone进行降序排序</span><br><span class="line">explain select id,age,phone from tb_user order by age desc, phone desc;</span><br><span class="line"># 根据age升序、phone降序排序</span><br><span class="line">explain select id,age,phone from tb_user order by age asc, phone desc;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li>
<li>尽量使用覆盖索引</li>
<li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则(ASC&#x2F;DESC)</li>
<li>如果不可避免地出现了filesort，大数据量排序时，可以适当增大排序缓冲区sort_buffer_size(默认256k)</li>
</ol>
<h4 id="group-by-优化"><a href="#group-by-优化" class="headerlink" title="group by 优化"></a>group by 优化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 删除当前的联合索引</span><br><span class="line">drop index idx_user_pro_age_sta on tb_user;</span><br><span class="line"># 执行分组操作，根据profession字段分组</span><br><span class="line">explain select profession,count(*) from tb_user group by profession;</span><br><span class="line">#创建索引</span><br><span class="line">create index idx_user_pro_age_sta on tb_user(profession,age,status);</span><br><span class="line"># 执行分组操作，根据profession字段分组</span><br><span class="line">explain select profession,count(*) from tb_user group by profession;</span><br><span class="line"># 执行分组操作，根据profession字段分组</span><br><span class="line">explain select profession,count(*) from tb_user group by profession,age;</span><br></pre></td></tr></table></figure>

<ul>
<li>在分组操作时，可以通过索引来提高效率</li>
<li>分组操作时，索引的使用也是满足最左前缀法则的</li>
</ul>
<h4 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h4><p>limit 在大数据量的分页时越往后所需时间越长，因为 limit 底层默认走的是全表扫描。官方给出的优化方案是通过覆盖索引和子查询的方式提高 limit 的分页效率。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 先拿到id</span><br><span class="line">select id from te_user order by id limit 10, 10;</span><br><span class="line"></span><br><span class="line"># 再查询id对应的行数据，mysql不支持in后跟limit，所以这里使用多表查询</span><br><span class="line">select</span><br><span class="line">    t.*</span><br><span class="line">from</span><br><span class="line">    te_user t,</span><br><span class="line">    (</span><br><span class="line">        select id from te_user order by  id limit 10, 10</span><br><span class="line">    ) tmp</span><br><span class="line">where</span><br><span class="line">    t.id = tmp.id</span><br></pre></td></tr></table></figure>

<p>上述方案使用了多表查询对 limit 语句进行优化。实际上，如果 limit 语句使用了 where 子句，可以在 where 子句所涉及到的字段添加索引，可以有效提高查询效率。</p>
<h4 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select count(*) from tb_user;</span><br></pre></td></tr></table></figure>

<ul>
<li>MySIAM引擎把一个表的总行数放到了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高（但是前提是没有 where 条件，即查询的是总数）</li>
<li>InnoDB引擎在执行count(*)时，需要把数据一行一行地从引擎中读取出来，然后累积计数</li>
</ul>
<p><strong>优化思路：自己计数(可以借助于redis这样的数 据库进行,但是如果是带条件的count又比较麻烦了)。</strong></p>
<p>count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加，最后返回累计值</p>
<p><strong>count的几种用法</strong></p>
<table>
<thead>
<tr>
<th>count用法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>count(*)</td>
<td>InnoDB引擎并不会把全部字段取出来，而是做了专门的优化，不取值，服务层直接按行进行累加</td>
</tr>
<tr>
<td>count(主键)</td>
<td>InnoDB引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加(主键不可能为NULL)</td>
</tr>
<tr>
<td>count(字段)</td>
<td><strong>没有not null约束</strong>：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层后，服务层判断是否为null，不为null，计数累加；<strong>有not null约束</strong>：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行累加</td>
</tr>
<tr>
<td>count(1)</td>
<td>InnoDB会遍历整张表，但不取值。服务层对于返回的每一层，放一个数字”1“进去，直接按行累加</td>
</tr>
</tbody></table>
<p><mark>根据效率排序，count(字段) &lt; count(主键id) &lt; count(1) ≈ count(*)</mark></p>
<h4 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update student set no = &#x27;2000100100&#x27; where id = 1; -- 有inidex</span><br><span class="line"></span><br><span class="line">upfate student set no = &#x27;2000100105&#x27; where name &#x27;张三&#x27;; -- 无index</span><br></pre></td></tr></table></figure>

<p><mark>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁</mark></p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图(view)是一种虚拟存在的表，视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的，通俗地讲，视图只保存了查询的SQL逻辑，不保存查询结果，所以我们在创建视图的时候，主要的任务就是创建这条SQL查询语句</p>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ul>
<li>创建</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create [or replace] view 视图名称[(列名列表)] as select语句 [with[cascaded | local]check option]</span><br></pre></td></tr></table></figure>

<ul>
<li>查询</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查看创建视图语句</span><br><span class="line">show create view 视图名称;</span><br><span class="line">-- 查看视图数据</span><br><span class="line">select * from 视图名称;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 方式一：</span><br><span class="line">create [or replace] view 视图名称[(列名列表)] as select语句 [with[cascaded | local] check option]</span><br><span class="line">-- 方式二：</span><br><span class="line">alter view 视图名称[(列名列表)] as select语句 [with[cascaded | local] check option]</span><br></pre></td></tr></table></figure>

<ul>
<li>删除</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop view [if exists] 视图名称 [,视图名称]...</span><br></pre></td></tr></table></figure>

<p>演示示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 创建视图</span><br><span class="line">create or replace view stu_v_1 as select id,name from student where id &lt;= 10;</span><br><span class="line">-- 查询视图</span><br><span class="line">show create view stu_v_1;</span><br><span class="line">select * from stu_v_1;</span><br><span class="line">select * from stu_v_1 where id &lt; 3;</span><br><span class="line">-- 修改视图</span><br><span class="line">create or replace view stu_v_1 as select id,name,no from student where id &lt;= 10;</span><br><span class="line">alter view stu_v_1 as select id,name from student where id &lt;= 10;</span><br><span class="line">-- 删除视图</span><br><span class="line">drop view if exists stu_v_1;</span><br></pre></td></tr></table></figure>

<h4 id="检查选项"><a href="#检查选项" class="headerlink" title="检查选项"></a>检查选项</h4><p>当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如 插 入，更新，删除，以使其符合视图的定义。 MySQL允许基于另一个视图创建视图，它还会检查依赖视 图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项： CASCADED 和 LOCAL ，默认值为 CASCADED 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create or replace view stu_v_1 as select id,name from student where id &lt;= 20 with cascaded check option; -- 检查选项</span><br></pre></td></tr></table></figure>

<p><strong>CASCADED(级联)</strong></p>
<p>比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 cascaded，但是v1视图 创建时未指定检查选项。 则在执行检查时，不仅会检查v2，还会级联检查v2的关联视图v1。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240310174245373.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240310174245373.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><strong>LOCAL(本地)</strong></p>
<p>比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 local ，但是v1视图创 建时未指定检查选项。 则在执行检查时，知会检查v2，不会检查v2的关联视图v1</p>
<p><img src="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240310174639914.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240310174639914.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>要使视图更新，视图中的行与基础表中的行之间必须存在<mark>一对一的关系</mark>，如果视图中包含以下任何一项，则视图不可更新：</p>
<ul>
<li>聚合函数或窗口函数(SUM()、MIN()、MAX()、COUNT()等)</li>
<li>DISTINCT</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>UNION 或 UNION ALL</li>
</ul>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li>简单</li>
</ul>
<p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件</p>
<ul>
<li>安全</li>
</ul>
<p>数据库可以授权，但不能授权到数据库中特定行和特定的列上，通过视图用户只能查询和修改他们所能见到的数据</p>
<ul>
<li>数据独立</li>
</ul>
<p>视图可以帮助用户屏蔽真实表结构变化带来的影响</p>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p><strong>存储过程</strong>是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 </p>
<p>存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用</p>
<p>特点：</p>
<ul>
<li>封装、复用</li>
<li>可以接收参数，也可以返回数据</li>
<li>减少网络交互，效率提升</li>
</ul>
<h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><ul>
<li>创建</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create procedure 存储过程名称([参数列表])</span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line">	--SQL语句</span><br><span class="line">	</span><br><span class="line">end;    </span><br></pre></td></tr></table></figure>

<ul>
<li>调用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 名称 ([参数]);</span><br></pre></td></tr></table></figure>

<ul>
<li>查看</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = &#x27;xxx&#x27;; -- 查询指定数据库的存储过程及状态信息</span><br><span class="line">SHOW CREATE PROCEDURE 存储过程名称; -- 查询某个存储过程的定义</span><br></pre></td></tr></table></figure>

<ul>
<li>删除</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP PROCEDURE [IF EXISTS] 存储过程名称;</span><br></pre></td></tr></table></figure>

<p>注意：在命令行中，执行创建存储过程的SQL时，需要通过关键字delimiter指定的SQL语句的结束符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$ -- 表示SQL语句将以$$符号表示结束符</span><br></pre></td></tr></table></figure>

<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p><strong>系统变量</strong>是MySQL服务器提供的，不是用户定义的，属于服务层面。分为全局变量(GLOBAL)、会话变量(SESSION)</p>
<ul>
<li>查看系统变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show [session | global] variables;  -- 查看所有系统变量</span><br><span class="line">show [session | global] variables like &#x27;......&#x27;;  -- 可以通过like模糊匹配方式查找变量</span><br><span class="line">select @@[session | global] 系统变量名; -- 查看指定变量的值</span><br></pre></td></tr></table></figure>

<ul>
<li>设置系统变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set [session | global] 系统变量名 = 值;</span><br><span class="line">set @@[session | global] 系统变量名 = 值;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>如果没有指定SESSION &#x2F; GLOBAL ，默认是SESSION，会话变量</li>
<li>mysql服务重新启动后，所设置的全局参数会失效，要想不失效，可以在&#x2F;etc&#x2F;my.cnf中配置</li>
</ul>
<p><strong>用户自定义变量</strong> 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用<mark>@变量名</mark>使用就可以，其作用域为当前连接</p>
<ul>
<li>赋值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set @var_name = expr[,@var_name = expr]...;</span><br><span class="line">set @var_name := expr[,@var_name := expr]...;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select @var_name := expr[,@var_name := expr]...;</span><br><span class="line">select 字段名 into @var_name from 表名;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @var_name;</span><br></pre></td></tr></table></figure>

<p>注意：用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL</p>
<p><strong>局部变量</strong> 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明，可用于存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN…END块</p>
<ul>
<li>声明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare 变量名 变量类型[default...];</span><br></pre></td></tr></table></figure>

<p>变量的类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等</p>
<ul>
<li>赋值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set 变量名 = 值;</span><br><span class="line">set 变量名 := 值;</span><br><span class="line">select 字段名 into 变量名 from 表名 ...;</span><br></pre></td></tr></table></figure>

<h4 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h4><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IF 条件1 THEN </span><br><span class="line">	...</span><br><span class="line">ELSE IF 条件2 THEN	-- 可选</span><br><span class="line">	...</span><br><span class="line">ELSE 				-- 可选</span><br><span class="line">	...</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>IN</td>
<td>该类参数作为输入，也就是需要调用时传入值</td>
<td>默认</td>
</tr>
<tr>
<td>OUT</td>
<td>该类参数作为输出，也就是该参数可以作为返回值</td>
<td></td>
</tr>
<tr>
<td>INOUT</td>
<td>既可以作为输入参数，也可以作为输出参数</td>
<td></td>
</tr>
</tbody></table>
<p>用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create procedure 存储过程名称 ([IN / OUT / INOUT 参数名 参数类型])</span><br><span class="line">begin</span><br><span class="line">		--SQL语句</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><ul>
<li>语法一</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case case_value</span><br><span class="line">		where when_value1 then statement_list1</span><br><span class="line">		[when when_value2] then statement_list2...</span><br><span class="line">		[else statement_list]</span><br><span class="line">end case;</span><br></pre></td></tr></table></figure>

<ul>
<li>语法二</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case</span><br><span class="line">		when search_condition1 then statement_list1</span><br><span class="line">		[when search_condition2 then statement_list2]...</span><br><span class="line">		[else statement_list]</span><br><span class="line">end case;</span><br></pre></td></tr></table></figure>

<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p><strong>while</strong></p>
<p>while循环是有条件的循环控制语句，满足条件后，再执行循环体中的SQL语句，具体语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑‘</span><br><span class="line">while 条件 do</span><br><span class="line">	SQL逻辑...</span><br><span class="line">end while;</span><br></pre></td></tr></table></figure>

<p><strong>repeat</strong></p>
<p>repeat是有条件的循环控制语句，当满足条件时退出循环，具体语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 先执行一次循环，任何判断逻辑是否满足，如果满足，则退出，如果不满足，则继续下一次循环</span><br><span class="line">repeat</span><br><span class="line">	SQL逻辑...</span><br><span class="line">	until 条件</span><br><span class="line">end repeat;</span><br></pre></td></tr></table></figure>

<p><strong>loop</strong></p>
<p>LOOP实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用来实现简单的死循环，LOOP可以配合以下两个语句使用：</p>
<ul>
<li>LEAVE：配合循环使用，退出循环</li>
<li>ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:] loop</span><br><span class="line">		SQL逻辑...</span><br><span class="line">end loop [end_label];</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leave label; -- 退出指定标记的循环体</span><br><span class="line">iterate label;  -- 直接进入下一次循环</span><br></pre></td></tr></table></figure>

<h4 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h4><p><strong>游标（CURSOR）</strong>是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下：</p>
<ul>
<li>声明游标</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare 游标名称 cursor for 查询语句;</span><br></pre></td></tr></table></figure>

<ul>
<li>打开游标</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open 游标名称;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取游标记录</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch 游标名称 into 变量[, 变量];</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭游标</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close 游标名称;</span><br></pre></td></tr></table></figure>

<p><strong>条件处理程序(Handler)：</strong>可以用来定义在流程控制结构执行过程中遇到的问题时相应的处理步骤，具体语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DECLARE handler_action HANDLER FOR condition_value [, condition_value]... statement ;</span><br><span class="line"></span><br><span class="line">handler_action的取值：</span><br><span class="line">	CONTINUE: 继续执行当前程序</span><br><span class="line">	EXIT: 终止执行当前程序</span><br><span class="line">condition_value的取值：</span><br><span class="line">	SQLSTATE sqlstate_value: 状态码，如 02000</span><br><span class="line">	SQLWARNING: 所有以01开头的SQLSTATE代码的简写</span><br><span class="line">	NOT FOUND: 所有以02开头的SQLSTATE代码的简写</span><br><span class="line">	SQLEXCEPTION: 所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写</span><br></pre></td></tr></table></figure>

<h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h3><p>存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的，具体语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION 存储函数名称 ([ 参数列表 ])</span><br><span class="line">RETURNS type [characteristic ...]</span><br><span class="line">BEGIN</span><br><span class="line">	-- SQL语句</span><br><span class="line">	RETURN ...;</span><br><span class="line">END ;</span><br><span class="line"></span><br><span class="line">characteristic说明：</span><br><span class="line">	DETERMINISTIC：相同的输入参数总是产生相同的结果</span><br><span class="line">	NO SQL：不包含SQL语句</span><br><span class="line">	READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 存储函数</span><br><span class="line">-- 计算1累加到n的值</span><br><span class="line">create function fun1(n int)</span><br><span class="line">returns int deterministic</span><br><span class="line">begin</span><br><span class="line">    declare sum int default 0;</span><br><span class="line">    while n&gt;0 do</span><br><span class="line">        set sum := sum + n;</span><br><span class="line">        set n := n - 1;</span><br><span class="line">    end while;</span><br><span class="line">    return sum;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">select fun1(100);</span><br></pre></td></tr></table></figure>

<p>在mysql8.0版本中binlog默认是开启的，一旦开启了，mysql就要求在定义存储过程时，需要指定 characteristic特性，否则就会报如下错误：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240311233650982.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240311233650982.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>触发器是与表有关的数据库对象，指在insert &#x2F; update &#x2F; delete之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录、数据校验等操作</p>
<p>使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是类似的，现在触发器还只支持行级触发，不支持语句级触发</p>
<table>
<thead>
<tr>
<th>触发器类型</th>
<th>NEW和OLD</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT型触发器</td>
<td>NEW表示将要或者已经新增的数据</td>
</tr>
<tr>
<td>UPDATE型触发器</td>
<td>OLD表示修改之前的数据，NEW表示将要或者已经修改之后的数据</td>
</tr>
<tr>
<td>DELETE型触发器</td>
<td>OLD表示将要或者已经删除的数据</td>
</tr>
</tbody></table>
<p>语法</p>
<ul>
<li>创建</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create trigger trigger_name</span><br><span class="line">before / after insert / update / delete</span><br><span class="line">on tbl_name for each row  -- 行级触发器</span><br><span class="line">begin</span><br><span class="line">		-- triger_stmt;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show triggers;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop trigger [schema_name.] trigger_name; -- 如果没有指定schema_name，默认为当前数据库</span><br></pre></td></tr></table></figure>

<h4 id="insert触发器"><a href="#insert触发器" class="headerlink" title="insert触发器"></a>insert触发器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- insert触发器</span><br><span class="line">-- 通过触发器记录tb_user表的数据变更日志，将变更日志插入到日志表user_logs中，包含增加、删除、修改</span><br><span class="line">create table user_logs(</span><br><span class="line">    id int(11) not null auto_increment,</span><br><span class="line">    operation varchar(20) not null comment &#x27;操作类型，insert / update / delete&#x27;,</span><br><span class="line">    operate_time datetime not null comment &#x27;操作时间&#x27;,</span><br><span class="line">    operate_id int(11) not null comment &#x27;操作id&#x27;,</span><br><span class="line">    operate_params varchar(500) comment &#x27;操作参数&#x27;,</span><br><span class="line">    primary key (`id`)  -- 反引号</span><br><span class="line">) engine = innodb default charset = utf8;</span><br><span class="line"></span><br><span class="line">-- 插入数据触发器</span><br><span class="line">create trigger tb_user_insert_trigger</span><br><span class="line">    after insert on tb_user for each row</span><br><span class="line">begin</span><br><span class="line">    insert into user_logs(id,operation,operate_time,operate_id,operate_params) values</span><br><span class="line">    (null,&#x27;insert&#x27;,now(),new.id,concat(&#x27;插入的数据内容为：id = &#x27;,new.id,&#x27; name = &#x27;,new.name,&#x27; phone = &#x27;,new.phone,&#x27;  email = &#x27;,new.email,&#x27; profession = &#x27;,new.profession));</span><br><span class="line">end;</span><br><span class="line">show triggers ;</span><br><span class="line"></span><br><span class="line">-- 删除</span><br><span class="line">drop trigger tb_user_insert_trigger;</span><br><span class="line"></span><br><span class="line">-- 插入数据</span><br><span class="line">insert into tb_user(id,name,phone,email,profession,age,gender,status,createtime) values</span><br><span class="line">(26,&#x27;张三&#x27;,&#x27;13978542354&#x27;,&#x27;zhangsan@163.com&#x27;,&#x27;软件工程&#x27;,19,&#x27;1&#x27;,&#x27;1&#x27;,now());</span><br></pre></td></tr></table></figure>

<h4 id="update触发器"><a href="#update触发器" class="headerlink" title="update触发器"></a>update触发器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 修改数据触发器</span><br><span class="line">create trigger tb_user_update_trigger</span><br><span class="line">    after update on tb_user for each row</span><br><span class="line">begin</span><br><span class="line">    insert into user_logs(id,operation,operate_time,operate_id,operate_params) values</span><br><span class="line">    (null,&#x27;update&#x27;,now(),new.id,</span><br><span class="line">     concat(&#x27;修改前的数据内容为：id = &#x27;,old.id,&#x27; name = &#x27;,old.name,&#x27; phone = &#x27;,old.phone,&#x27;  email = &#x27;,old.email,&#x27; profession = &#x27;,old.profession,</span><br><span class="line">            &#x27;修改后的数据内容为：id = &#x27;,new.id,&#x27; name = &#x27;,new.name,&#x27; phone = &#x27;,new.phone,&#x27;  email = &#x27;,new.email,&#x27; profession = &#x27;,new.profession));</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">show triggers ;</span><br><span class="line"></span><br><span class="line">update tb_user set age = 32 where id = 25;</span><br></pre></td></tr></table></figure>

<h4 id="delete触发器"><a href="#delete触发器" class="headerlink" title="delete触发器"></a>delete触发器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 删除数据触发器</span><br><span class="line">create trigger tb_user_delete_trigger</span><br><span class="line">    after delete on tb_user for each row</span><br><span class="line">begin</span><br><span class="line">    insert into user_logs(id,operation,operate_time,operate_id,operate_params) values</span><br><span class="line">    (null,&#x27;delete&#x27;,now(),old.id,concat(&#x27;删除的数据内容为：id = &#x27;,old.id,&#x27; name = &#x27;,old.name,&#x27; phone = &#x27;,old.phone,&#x27;  email = &#x27;,old.email,&#x27; profession = &#x27;,old.profession));</span><br><span class="line">end;</span><br><span class="line">delete from tb_user where id = 26;</span><br><span class="line">show triggers ;</span><br></pre></td></tr></table></figure>

<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><strong>锁</strong>是计算机协调多个进程或者线程并发访问某一资源的机制，在数据库中，除传统的计算资源(CPU、RAM、I&#x2F;O)的争用以外，数据也是一种提供许多用户共享的资源，如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问虚性能的一个重要因素，从这个角度上来讲，锁对数据库而言显得尤其重要，也更加复杂。</p>
<p>MySQL中的锁，按照锁的粒度分为以下三类：</p>
<ol>
<li>全局锁：锁定数据库中的所有表</li>
<li>表级锁：每次操作锁定整张表</li>
<li>行级锁：每次操作锁住对应的行数据</li>
</ol>
<h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞，其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性</p>
<p><img src="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240312163035355.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240312163035355.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>语法</p>
<ul>
<li>加全局锁</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush tables with read lock ;</span><br></pre></td></tr></table></figure>

<ul>
<li>数据备份</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot –p1234 itcast &gt; itcast.sql</span><br></pre></td></tr></table></figure>

<ul>
<li>释放锁</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables ;</span><br></pre></td></tr></table></figure>

<p>特点</p>
<p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p>
<ol>
<li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆</li>
<li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志(binlog)，会导致主从延迟</li>
</ol>
<p>在InnoDB引擎中，我们可以在备份时加入参数 –single-transaction 参数来完成不加锁的一致性数据备份</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump --single-transaction -uroot –p1234 itcast &gt; itcast.sql</span><br></pre></td></tr></table></figure>

<h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p>表级锁，每次操作锁定整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中</p>
<p>对于表级锁，主要分为以下三类：</p>
<ul>
<li>表锁</li>
<li>元数据锁（meta data lock，MDL）</li>
<li>意向锁</li>
</ul>
<p><strong>表锁</strong></p>
<p>对于表锁，分为以下两类：</p>
<ul>
<li>表共享读锁（read lock）</li>
<li>表独占写锁（write lock）</li>
</ul>
<p>语法</p>
<ul>
<li>加锁：lock tables 表名… read &#x2F; write</li>
<li>释放锁：unlock  tables &#x2F; 客户端断开连接</li>
</ul>
<p>读锁</p>
<p><img src="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240312170153529.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240312170153529.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>写锁</p>
<p><img src="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240312170635797.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240312170635797.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><mark>结论: 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</mark></p>
<p><strong>元数据锁（meta data lock，MDL）</strong></p>
<p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上，MDL锁主要作用是维护表元数据的数据一致性，在表上有活动业务时，不可以对元数据进行写入操作。<mark>为了避免DML与DDL产生冲突，保证对写的正确性</mark></p>
<p>在MySQL5.5中引入了MDL，当对一张表进行增删改查时，加MDL读锁（共享），当对表结构进行变更操作的时候，加MDL写锁（排他）。</p>
<table>
<thead>
<tr>
<th>对应SQL</th>
<th>锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock tables xxx read &#x2F; write</td>
<td>SHARED_READ_ONLY &#x2F; SHARED_NO_READ_WRITE</td>
<td></td>
</tr>
<tr>
<td>select、select … lock in share mode</td>
<td>SHARED_READ<strong>（本会话只能读不能写，其他会话可以读也可以写）</strong></td>
<td>与SHARED_READ、 SHARED_WRITE兼容，与 EXCLUSIVE互斥</td>
</tr>
<tr>
<td>insert、update、delete、select … for update</td>
<td>SHARED_WRITE<strong>（所有会话都可以读，但只有本会话可以写）</strong></td>
<td>与SHARED_READ、 SHARED_WRITE兼容，与 EXCLUSIVE互斥</td>
</tr>
<tr>
<td>alter table …</td>
<td>EXCLUSIVE<strong>（本会话可以读也可以写，但是别的会话不能读也不能写）</strong></td>
<td>与其他的MDL都互斥</td>
</tr>
</tbody></table>
<p>查看元数据锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks ;</span><br></pre></td></tr></table></figure>

<p><strong>意向锁</strong></p>
<p>注意到一个场景：当我们利用<code>update</code>语句对表的数据进行操作时，这个时候系统会自动给表加上一个元数据锁，使得所有会话都可以读，但是只有本会话可以写。假设这个时候有另外一个客户端对这个表执行<code>lock tables xxx read / write</code>操作，欲给这个表上一个表锁，这时会发生锁的冲突。为了避免锁的冲突，客户端需要一行一行检查表的行数据以确定是否有元数据锁，这会使得性能下降。</p>
<p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行 数据是否加锁，使用意向锁来减少表锁的检查。</p>
<p>意向锁分有：</p>
<ol>
<li>意向共享锁（IS）：由语句select … lock in share mode 添加，与表锁读锁（read）兼容，与表锁写锁（write）互斥。</li>
<li>意向排他锁（IX）：由insert、update、delete、select … for update 添加，与表锁读锁和写锁都互斥，<strong>意向锁之间不会互斥</strong>。</li>
</ol>
<p>可以通过以下SQL语句来查看意向锁及行锁的加锁情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from</span><br><span class="line">performance_schema.data_locks;</span><br></pre></td></tr></table></figure>

<p><mark>注意：一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</mark></p>
<h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><p>行级锁，每次操作锁住对应的行数据，锁定粒度最小，发生锁冲突的概率最低，并发度最高，应用在InnoDB存储引擎中</p>
<p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录的锁，对于行级锁，主要分为以下三大类：</p>
<ul>
<li>行锁（Record  Lock）：锁定单个行记录的锁，防止其他事务对行进行update和delete。在RC、RR隔离级别下都支持</li>
<li>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持</li>
<li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap，在RR隔离级别下支持</li>
</ul>
<p><strong>行锁</strong></p>
<p>InnoDB实现了以下两种类型的行锁：</p>
<ol>
<li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同的数据集的排他锁</li>
<li>排他锁（X）：允许获取其他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁</li>
</ol>
<table>
<thead>
<tr>
<th>当前锁类型（下）&#x2F; 请求锁类型（右）</th>
<th>S（共享锁）</th>
<th>X（排他锁）</th>
</tr>
</thead>
<tbody><tr>
<td>S（共享锁）</td>
<td>兼容</td>
<td>冲突</td>
</tr>
<tr>
<td>X（排他锁）</td>
<td>冲突</td>
<td>冲突</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>SQL</th>
<th>行锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>UPDATE …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>SELECT（正常）</td>
<td><mark>不加任何锁</mark></td>
<td></td>
</tr>
<tr>
<td>SELECT … LOCK IN SHARE MODE</td>
<td>共享锁</td>
<td>需要手动在SELECT之后加LOCK SHARE MODE</td>
</tr>
<tr>
<td>SELECT … FOR UPDATE</td>
<td>拍他锁</td>
<td>需要手动在SELECT之后加FOR UPDATE</td>
</tr>
<tr>
<td>DELETE …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
</tbody></table>
<p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜 索和索引扫描，以防止幻读。</p>
<ul>
<li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li>
<li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会<mark>升级为表锁</mark>。</li>
</ul>
<p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from</span><br><span class="line">performance_schema.data_locks;</span><br></pre></td></tr></table></figure>

<p><strong>间隙锁&amp;临键锁</strong></p>
<p>默认情况下，InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读</p>
<ol>
<li>索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁</li>
<li>索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁</li>
<li>索引上的范围查询（唯一索引）– 会访问到不满足条件的第一个值为止</li>
</ol>
<p><mark>注意：间隙锁唯一目的是防止其他事务插入间隙，间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一个间隙上采用间隙锁</mark></p>
<h3 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h3><p>逻辑存储结构</p>
<p>InnoDB的逻辑存储结构如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240313085644609.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240313085644609.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<ol>
<li><strong>表空间</strong>， 表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在 8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。 </li>
<li><strong>段</strong> ，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段 （Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的 非叶子节点。段用来管理多个Extent（区）。</li>
<li><strong>区</strong>，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一 个区中一共有64个连续的页。</li>
<li><strong>页</strong>，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性， InnoDB 存储引擎每次从磁盘申请 4-5 个区。</li>
<li><strong>行</strong>，InnoDB 存储引擎数据是按行进行存放的。在行中默认有两个字段：</li>
</ol>
<ul>
<li>Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</li>
<li>Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个 隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
<h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><h5 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h5><p>MySQL5.5版本开始，默认使用InnoDB引擎，它擅长事务处理，具有奔溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240313090552575.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240313090552575.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能 弥补这两者之间的I&#x2F;O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁 盘I&#x2F;O。 在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及 InnoDB的锁信息等等。</p>
<p><strong>Buffer Pool</strong>：缓冲池是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池中没有数据，则从磁盘中加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p>
<p>缓冲池以Page页为单位，底层采用链表数据结构管理Page，根据状态，将Page分为三种类型：</p>
<ul>
<li>free page：空闲page，未被使用</li>
<li>clean page：被使用page，数据没有被修改过</li>
<li>dirty page：脏页，被使用page，数据被修改过，页中数据与磁盘的数据产生了不一致</li>
</ul>
<p>在专用服务器上，通常将多达80％的物理内存分配给缓冲池 。参数设置： <code>show variables like &#39;innodb_buffer_pool_size&#39;</code>;</p>
<p><strong>Change Buffer</strong>：更改缓冲区（针对非唯一二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer 中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p>
<p><strong>Change Buffer 存在的意义</strong>：</p>
<p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新 可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了 ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p>
<p><strong>Adaptive Hash Index</strong>：自适应hash索引，用于优化对Buffer Pool 数据的查询。InnoDB存储引擎会监控对表上各索引页的查询，如果观察到hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。</p>
<p><mark>自适应哈希索引，无需人工干预，是系统根据情况自动完成的。</mark></p>
<p>参数：<code>adpative_hash_index</code></p>
<p><strong>Log Buffer</strong>：日志缓冲区，用来保存要写入到磁盘中的log日志数据（red log、undo log），默认大小为16MB，日志缓冲区的日志会定期刷新到磁盘中，如果有需要更新、插入或者删除许多行的事务，增加日志缓冲区的大小可以节省磁盘I &#x2F; O。</p>
<p>参数：</p>
<p><code>innodb_log_buffer_size</code>：缓冲区大小</p>
<p><code>innodb_flush_log_trx_commit</code>：日志刷新到磁盘时机</p>
<ul>
<li>1：日志在每次事务提交时写入并刷新到磁盘中</li>
<li>0：每秒将日志写入并刷新到磁盘一次</li>
<li>2：日志在每次事务提交之后写入，并每秒刷新到磁盘一次</li>
</ul>
<h5 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h5><p><strong>System Tablespace</strong>：系统表空间是更改缓冲区的存储区域，如果表是在系统表空间而不是每个表文件或者通用表空间中创建的，它也可能包含表和索引数据。（在MySQL5.x版本中还包含InnoDB数据字典、undolog等）</p>
<p>参数：<code>innnodb_data_file_path</code></p>
<p><strong>File-Per-Table Tablespaces</strong>：每个表的文件表空间包含单个InnoDB表的数据和索引，并存储在文件系统上的单个数据文件上</p>
<p>参数：<code>innodb_file_per_table</code></p>
<p><strong>General Tablespaces</strong>：通用表空间，需要通过<code>CREATE TABLESPACE</code>语法创建通用表空间，在创建表时，可以指定该表空间</p>
<ul>
<li>创建表空间</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLESPACE ts_name ADD DATAFILE &#x27;file_name&#x27; ENGINE = engine_name;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建表时指定表空间</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE xxx ... TABLESPACE ts_name;</span><br></pre></td></tr></table></figure>

<p><strong>Updo Tablespaces</strong>：撤销表空间，MySQL实例在初始化会自动创建两个默认的undo表空间(初始大小16M)，用于存储undo log 日志</p>
<p><strong>Temporary Tablespaces</strong>：InnoDB使用会话临时表空间和全局临时表空间，存储用户创建的临时表等数据</p>
<p><strong>Doublewrite Buffer Files</strong>：双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件 中，便于系统异常时恢复数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240313211647637.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240313211647637.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><strong>Red Log</strong>：重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所 有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。以循环方式写入重做日志文件，涉及两个文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240313211826679.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240313211826679.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h5 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h5><p><img src="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240313211907224.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240313211907224.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在InnoDB的后台线程中，分为4类，分别是：Master Thread 、IO Thread、Purge Thread、 Page Cleaner Thread。</p>
<p><strong>Master Thread</strong></p>
<p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中，保持数据的一致性，还包括脏页的刷新、合并插入缓冲、undo页的回收</p>
<p><strong>IO Thread</strong></p>
<p>在InnoDB存储引擎中大量使用了AIO请求，这样可以极大地提高数据库的性能，而<code>IO Thread </code>主要负责这些IO请求的回调</p>
<table>
<thead>
<tr>
<th>线程类型</th>
<th>默认个数</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td>Read thread</td>
<td>4</td>
<td>负责读操作</td>
</tr>
<tr>
<td>Write thread</td>
<td>4</td>
<td>负责写操作</td>
</tr>
<tr>
<td>Log thread</td>
<td>1</td>
<td>负责将日志缓冲区刷新到磁盘</td>
</tr>
<tr>
<td>Insert buffer thread</td>
<td>1</td>
<td>负责将写缓冲区内容刷新到磁盘</td>
</tr>
</tbody></table>
<p>我们可以通过以下的这条指令，查看到InnoDB的状态信息，其中就包含IO Thread信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status ;</span><br></pre></td></tr></table></figure>

<p><strong>Purge Thread</strong></p>
<p>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收。</p>
<p><strong>Page Cleaner Thread</strong></p>
<p>协助Master Thread 刷新脏页到磁盘的线程，它可以减轻Masrter Thread 的工作压力，减少阻塞</p>
<h4 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h4><p><strong>事务</strong> 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或者撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<p><strong>事务四大特性(ACID)</strong></p>
<ul>
<li><p>原子性(Atomicty)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</p>
</li>
<li><p>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</p>
</li>
<li><p>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响下的独立环境下运行</p>
</li>
<li><p>持久性(Durability)：事务一旦提交或者回滚，它对数据库中的数据的改变就是永久的</p>
</li>
</ul>
<p>而对于这四大特性，实际上分为两个部分。 其中的原子性、一致性、持久化，实际上是由InnoDB中的两份日志来保证的，一份是<code>redo log</code>日志，一份是<code>undo log</code>日志。 而持久性是通过数据库的锁， 加上<code>MVCC</code>来保证的。</p>
<h5 id="red-log"><a href="#red-log" class="headerlink" title="red log"></a><strong>red log</strong></h5><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性</p>
<p>该日志文件由两部分组成：重做缓冲日志（redo log buffer）以及重做日志文件（redo log file），前者是在内存中，后者是在磁盘中。当事务提交之后会把所有修改信息都存到该日志中，再用于刷新脏页到磁盘，发生错误时，进行数据恢复使用</p>
<p>在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数据页。 当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中的数据修改，修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却没有持久化下来，这就出现问题了，没有保证事务的持久性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240313214159384.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240313214159384.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>有了<code>redo log</code>之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在<code>redo log buffer</code>中。在事务提交时，会将<code>redo log buffer</code>中的数据刷新到<code>redo log</code>磁盘文件中。 过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于<code>redo log</code>进行数据 恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时<code>redo log</code>就没有作用了，就可以删除了，所以存在的两个<code>redo log</code>文件是循环写的。</p>
<p>在业务操作中，我们操作数据一般都是<mark>随机读写磁盘的，而不是顺序读写磁盘。</mark> 而<code>redo log</code>在 往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这种先写日志的方式，称之为 WAL（Write-Ahead Logging）。</p>
<h5 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h5><p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : <mark>提供回滚</mark>(保证事务的原子性) 和<mark> MVCC</mark>(多版本并发控制) 。</p>
<p>undo log和redo log记录物理日志不一样，它是<mark>逻辑日志</mark>。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的 update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p>
<p> <strong>Undo log销毁</strong>：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些 日志可能还用于MVCC。   </p>
<p><strong>Undo log存储</strong>：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含1024个undo log segment。</p>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><ul>
<li>当前读</li>
</ul>
<p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁，对于我们日常的操作，如：select … lock in share mode （共享锁），select … for update、update、insert、delete（排他锁）都是一种当前读。</p>
<ul>
<li>快照读</li>
</ul>
<p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读</p>
<ul>
<li>Read Committed：每次select，都生成一个快照读</li>
<li>Repeatable Read：开始事务后第一个select语句才是快照读的地方</li>
<li>Serializable：快照读会退化为当前读</li>
</ul>
<p><strong>MVCC</strong>，全称<code>Multi-Version Concurrency Control</code>，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、<code>readView</code>。 </p>
<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><ul>
<li>记录当中的隐藏字段</li>
</ul>
<table>
<thead>
<tr>
<th>隐藏字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>DB_TRX_ID</td>
<td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID</td>
</tr>
<tr>
<td>DB_ROLL_PTR</td>
<td>回滚指针，指向这条记录的上一个版本，用于配合<code>undo log</code>，指向上一个版本</td>
</tr>
<tr>
<td>DB_ROW_ID</td>
<td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</td>
</tr>
</tbody></table>
<p><code>idb2sdi 表空间文件名</code>：查看表空间文件内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibd2sdi 表名.ibd</span><br></pre></td></tr></table></figure>

<ul>
<li>undo log</li>
</ul>
<p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志，当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除，而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会被立即删除</p>
<ul>
<li>undo log版本链</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240415222158144.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240415222158144.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20240415222158144"></p>
<p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p>
<ul>
<li>readview</li>
</ul>
<p>ReadView（读视图）是<strong>快照读</strong>SQL执行时MVCC提取数据的依据，记录并维护当前活跃的事务（未提交的）id。</p>
<p>ReadView包含了四个核心字段：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>m_ids</td>
<td>当前活跃的事务id集合</td>
</tr>
<tr>
<td>min_trx_id</td>
<td>最小活跃事务id</td>
</tr>
<tr>
<td>max_trx_id</td>
<td>预分配事务id，当前最大事务id1（因为事务id是自增的）</td>
</tr>
<tr>
<td>creator_trx_id</td>
<td>ReadView创建者的事务id</td>
</tr>
</tbody></table>
<p><mark>版本链数据访问规则</mark></p>
<p>trx_id：代表的是当前事务ID。</p>
<ol>
<li><p>trx_id &#x3D;&#x3D; creator_trx_id 	可以访问当前版本	→	说明数据是当前这个事务更改的</p>
</li>
<li><p>trx_id &lt; min_trx_id	可以访问当前版本	→	说明数据已经提交了</p>
</li>
<li><p>trx_id &gt; max_trx_id   不可以访问该版本    →    说明当前事务是在ReadView生成之后才开始</p>
</li>
<li><p>min_trx_id &lt;&#x3D; trx_id &lt;&#x3D; max_trx_id  如果trx_id不在m_ids中是可以访问该版本的   →   说明数据已经提交了</p>
</li>
</ol>
<p>不同的隔离级别，生成ReadView的时机不同：</p>
<ul>
<li>READ COMMITTED：在事务中每一次执行快照读时生成ReadView</li>
<li>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView</li>
</ul>
<p><mark>RC隔离级别下，在事务中的每一次执行快照读时生成ReadView</mark></p>
<p><img src="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240416204531685.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240416204531685.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20240416204531685"></p>
<p><mark>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView</mark></p>
<p><img src="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240416204519133.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/hnuyl16/images/image-20240416204519133.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20240416204519133"></p>

      </div>
      <div class="post-tags-categories">
        
        <div class="tags">
          
            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="">
              数据库
            </a>
          
            <a href="/tags/MySQL/" class="">
              MySQL
            </a>
          
        </div>
        
      </div>
      
        <div class="copyright">
  <ul class="post-copyright">
    <li class="post-copyright-author">
    <strong>作者:  </strong>余年</a>
    </li>
    <li class="post-copyright-link">
    <strong>文章链接:  </strong>
    <a href="/2024/03/03/MySQL/" target="_blank" title="MySQL">http://hnuyl16.github.io/2024/03/03/MySQL/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明:   </strong>
      本网站所有文章除特别声明外,均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
      许可协议。转载请注明出处!
    </li>
  </ul>
<div>
      
    </article>
    <!-- 上一篇文章和下一篇文章 -->
    
      <!-- 文章详情页的上一页和下一页 -->
<div class="post-nav">



  
  <div class="post-nav-prev post-nav-item">
    <div class="post-nav-img" style="background-size: cover; 
      background-position: center center;">
      <img class="lazyload lazyload placeholder" src="https://picx.zhimg.com/80/v2-9c50d3af0bc62a0e8b6e89e24c769317_1440w.webp" class="lazyload placeholder" data-srcset="https://picx.zhimg.com/80/v2-9c50d3af0bc62a0e8b6e89e24c769317_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
    </div>
    <a href="/2024/03/12/Javaweb/" class="post-nav-link">
      <div class="title">
        <i class="fas fa-angle-left"></i> 上一篇:
        <div class="title-text">Javaweb</div>
      </div>
      
      <!-- <div class="content">
        JavaWeb前端vuevue是一套前端框架，免除原生JavaScript中的DOM操作，简化书写。
基于MVVM(Mo
      </div> -->
    </a>
  </div>



  
  <div class="post-nav-next post-nav-item">
    <div class="post-nav-img" style="background-size: cover; 
      background-position: center center;">
      <img class="lazyload lazyload placeholder" src="https://picx.zhimg.com/80/v2-9c50d3af0bc62a0e8b6e89e24c769317_1440w.webp" class="lazyload placeholder" data-srcset="https://picx.zhimg.com/80/v2-9c50d3af0bc62a0e8b6e89e24c769317_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" src="" alt="">
    </div>
    <a href="/2024/02/04/%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-nav-link">
      <div class="title">
        下一篇: <i class="fas fa-angle-right"></i>
        <div class="title-text">字符串</div>
      </div>
      <!-- <div class="content">
        字符串字典树对于常见的字符串匹配问题，在n个字符中查找某个字符串。
若采用暴力方法，需要逐一匹配每个字符串，时间复杂度为
      </div> -->
    </a>
  </div>

</div>

    
    

    <!-- 打赏 -->
    

    <!-- 分享 -->
    
      <!-- https://github.com/overtrue/share.js -->
<!-- 文章详情页的分享 -->
<div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>

<script defer src="/js/shareJs/social-share.min.js"></script>
</script>

<style>
  .social-share {
    margin: 20px 0;
  }
</style>


    
    
    <!-- 评论 -->
    <!-- 评论 -->

  <div id="myComment">
    
      <div id="gitment-container"></div>

    
  </div>


<!-- 还需要在后面这个地址里设置script, comment script in themes\hexo-theme-bamboo\layout\_partial\scripts\index.ejs -->


  </div>

  <!-- 目录 -->
  <aside id='l_side'>
  
    
      <section class="widget side_blogger">
  <div class='content'>
    
      
        <a class='avatar flat-box rectangle' href='/about/'>
          <img src='/medias/logo.png'/>
        </a>
      
    
    
      <div class='text'>
        
          <h2>余年</h2>
        
        
          <p>在校大学生</p>

        
        
          <p><span id="jinrishici-sentence">余年的个人博客</span></p>
          <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
              
            </a>
          
        
          
            <a href="mailto:me@xxx.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
              
            </a>
          
        
          
            <a href="https://hnuyl16.github.io/"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
              
            </a>
          
        
          
            <a href="tencent://AddContact/?fromId=50&amp;fromSubId=1&amp;subcmd=all&amp;uin=2098255196"
              class="social fab fa-qq flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
              
            </a>
          
        
      </div>
    
  </div>
</section>

    
  
  
  

  <div class="layout_sticky">    
    
      
<section class="widget side_toc">
  
  <header>
    
      <i style="color: " class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name' style="color: ">本文目录</span>
    
  </header>


  <div class='content'>
    <div class="toc-main">
      <div class="toc-content">
        <!-- <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL"><span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL"><span class="toc-text">SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL%E9%80%9A%E7%94%A8%E8%AF%AD%E6%B3%95"><span class="toc-text">SQL通用语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DDL"><span class="toc-text">DDL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DML"><span class="toc-text">DML</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DQL"><span class="toc-text">DQL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DCL"><span class="toc-text">DCL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-text">约束</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F"><span class="toc-text">外键约束</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-text">多表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E5%85%B3%E7%B3%BB"><span class="toc-text">多表关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"><span class="toc-text">连接查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-text">子查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C"><span class="toc-text">事务操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7-ACID"><span class="toc-text">事务四大特性(ACID)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="toc-text">并发事务问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">事务隔离级别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6"><span class="toc-text">进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">MySQL体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-1"><span class="toc-text">存储引擎</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="toc-text">索引结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-text">索引分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AF%AD%E6%B3%95"><span class="toc-text">索引语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">SQL性能分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-text">使用规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E4%BC%98%E5%8C%96"><span class="toc-text">SQL优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-text">插入数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E4%BC%98%E5%8C%96"><span class="toc-text">主键优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#order-by-%E4%BC%98%E5%8C%96"><span class="toc-text">order by 优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#group-by-%E4%BC%98%E5%8C%96"><span class="toc-text">group by 优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#limit%E4%BC%98%E5%8C%96"><span class="toc-text">limit优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#count%E4%BC%98%E5%8C%96"><span class="toc-text">count优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#update%E4%BC%98%E5%8C%96"><span class="toc-text">update优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE"><span class="toc-text">视图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E9%80%89%E9%A1%B9"><span class="toc-text">检查选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0"><span class="toc-text">更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-text">作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">存储过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text">变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#if%E5%88%A4%E6%96%AD"><span class="toc-text">if判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case"><span class="toc-text">case</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-text">循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B8%E6%A0%87"><span class="toc-text">游标</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0"><span class="toc-text">存储函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-text">触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#insert%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-text">insert触发器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#update%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-text">update触发器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#delete%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-text">delete触发器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81"><span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-text">全局锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-text">表级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-text">行级锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E5%BC%95%E6%93%8E"><span class="toc-text">InnoDB引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-text">架构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-text">内存结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84"><span class="toc-text">磁盘结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="toc-text">后台线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86"><span class="toc-text">事务原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#red-log"><span class="toc-text">red log</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#undo-log"><span class="toc-text">undo log</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVCC"><span class="toc-text">MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">实现原理</span></a></li></ol></li></ol></li></ol></li></ol></li></ol> -->
        <div class="toc"></div>
      </div>
    </div>
  </div>
</section>
<!-- 手机端目录按钮 -->
<div id="toc-mobile-btn">
  <i class="fas fa-list-ul" aria-hidden="true"></i>
</div>

      
  <section class="widget side_recent_post">
    
  <header>
    
      <a style="color: " href='/tags/'><i class="fas fa-book fa-fw" aria-hidden="true"></i><span class='name'>最新文章</span></a>
    
  </header>


    <div class='content'>
      
      <!-- hash算法 -->
      
      <div class="aside-list">
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2025/07/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-1/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic3.zhimg.com/80/v2-e5c15010b8ba4608a1974403a02a2da0_1440w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-e5c15010b8ba4608a1974403a02a2da0_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">07-28</span>
                
              </div>
              <a class="post-title" href="/2025/07/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-1/">机器学习</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2025/07/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://picx.zhimg.com/80/v2-b44931ea513e5f7b3b06f2703f79653c_1440w.webp" class="lazyload placeholder" data-srcset="https://picx.zhimg.com/80/v2-b44931ea513e5f7b3b06f2703f79653c_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">07-28</span>
                
              </div>
              <a class="post-title" href="/2025/07/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/">微信小程序开发</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2025/07/28/Vue/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pica.zhimg.com/80/v2-573ac3e25de03fad9c32add5a05e5cfc_1440w.webp" class="lazyload placeholder" data-srcset="https://pica.zhimg.com/80/v2-573ac3e25de03fad9c32add5a05e5cfc_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">07-28</span>
                
              </div>
              <a class="post-title" href="/2025/07/28/Vue/">Vue</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2025/07/28/springBoot/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic4.zhimg.com/80/v2-83ea273b88e119d9615aed0d89aad4ab_1440w.webp" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-83ea273b88e119d9615aed0d89aad4ab_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">07-28</span>
                
              </div>
              <a class="post-title" href="/2025/07/28/springBoot/">springBoot</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2025/07/28/Maven/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic3.zhimg.com/80/v2-7cfc909ebe8d83683909846edd6b5232_1440w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-7cfc909ebe8d83683909846edd6b5232_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">07-28</span>
                
              </div>
              <a class="post-title" href="/2025/07/28/Maven/">Maven</a>
            </div>
          </div>
        
      </div>
    </div>
  </section>

    
  </div>
</aside>

  <!-- 图片放大 Wrap images with fancybox support -->
  <script defer src="/js/wrapImage.js"></script>
</div>

<!-- 文章详情页背景图 -->
<div id="appBgSwiper" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -2;"
	:style="{'background-color': bgColor ? bgColor : 'transparent'}">
	<transition-group tag="ul" :name="names">
		<li v-for='(image,index) in img' :key='index' v-show="index === mark" class="bg-swiper-box">
			<img :src="image" class="bg-swiper-img no-lazy">
		</li>
	</transition-group>
</div>
<script>
	var vm = new Vue({
		el: '#appBgSwiper',
		data: {
			names: '' || 'fade' || 'fade', // translate-fade fade
			mark: 0,
			img: [],
			bgColor: '',
			time: null
		},
		methods: {   //添加方法
			change(i, m) {
				if (i > m) {
					// this.names = 'fade';
				} else if (i < m) {
					// this.names = 'fade';
				} else {
					return;
				}
				this.mark = i;
			},
			prev() {
				// this.names = 'fade';
				this.mark--;
				if (this.mark === -1) {
					this.mark = 3;
					return
				}
			},
			next() {
				// this.names = 'fade';
				this.mark++;
				if (this.mark === this.img.length) {
					this.mark = 0;
					return
				}
			},
			autoPlay() {
				// this.names = 'fade';
				this.mark++;
				if (this.mark === this.img.length) {
					this.mark = 0;
					return
				}
			},
			play() {
				let bgImgDelay = '' || '180000'
				let delay = parseInt(bgImgDelay) || 180000;
				this.time = setInterval(this.autoPlay, delay);
			},
			enter() {
				clearInterval(this.time);
			},
			leave() {
				this.play();
			}
		},
		created() {
			this.play()
		},
		beforeDestroy() {
			clearInterval(this.time);
		},
		mounted() {
			let prop = '' || '';
			let isImg = prop.includes('.bmp') || prop.includes('.jpg') || prop.includes('.png') || prop.includes('.tif') || prop.includes('.gif') || prop.includes('.pcx') || prop.includes('.tga') || prop.includes('.exif') || prop.includes('.fpx') || prop.includes('.psd') || prop.includes('.cdr') || prop.includes('.pcd') || prop.includes('.dxf') || prop.includes('.ufo') || prop.includes('.eps') || prop.includes('.ai') || prop.includes('.raw') || prop.includes('.WMF') || prop.includes('.webp') || prop.includes('.jpeg') || prop.includes('http://') || prop.includes('https://')
			if (isImg) {
				let img = prop.split(',');
				let configRoot = '/'
				let arrImg = [];
				img.forEach(el => {
					var Expression = /http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- .\/?%&=]*)?/;
					var objExp = new RegExp(Expression);

					if (objExp.test(el)) {
						// http or https
						arrImg.push(el);
					} else {
						// 非http or https开头
						// 本地文件
						let firstStr = el.charAt(0);
						if (firstStr == '/') {
							el = el.substr(1); // 删除第一个字符 '/',因为 configRoot最后一个字符为 /
						}
						el = configRoot + el;
						arrImg.push(el);
					}
				})
				this.img = arrImg;
			} else {
				this.bgColor = prop;
			}
		}
	})
</script>

<style>
	.bg-swiper-box {
		position: absolute;
		display: block;
		width: 100%;
		height: 100%;
	}

	.bg-swiper-img {
		object-fit: cover;
		width: 100%;
		height: 100%;
	}
</style>




  <script>
  function loadMermaid() {
    if (document.getElementsByClassName('mermaid').length) {
      if (window.mermaidJsLoad) mermaid.init()
      else {
        loadScript('https://unpkg.com/mermaid/dist/mermaid.min.js').then(() => {
          window.mermaidJsLoad = true
          mermaid.initialize({
            theme: 'default',
          })
          if ('true') {
            mermaid.init();
          }
        })
      }
    }
  };
  document.addEventListener("DOMContentLoaded", function () {
    loadMermaid();
  })

  document.addEventListener('pjax:complete', function () {
    loadMermaid();
  })
  
</script>


      </main>
    </div>

    <!-- 页脚 -->
    
  
  
    <!-- 底部鱼儿跳动效果，依赖于jquery-->
<div id="j-fish-skip" style=" position: relative;height: 153px;width: auto;"></div>
<script defer>
  var RENDERER = {
    POINT_INTERVAL: 5,
    FISH_COUNT: 3,
    MAX_INTERVAL_COUNT: 50,
    INIT_HEIGHT_RATE: .5,
    THRESHOLD: 50,
    FISH_COLOR: '',
    init: function () {
      this.setFishColor(); this.setParameters(), this.reconstructMethods(), this.setup(), this.bindEvent(), this.render()
    },
    setFishColor: function () {
      let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');
      if (isDark) {
        this.FISH_COLOR = '#222'; // 暗黑色，有时间把这整成一个变量
      } else {
        this.FISH_COLOR = '' || 'rgba(66, 185, 133, 0.8)';
      }
    },
    setParameters: function () {
      this.$window = $(window), this.$container = $("#j-fish-skip"), this.$canvas = $("<canvas />"), this.context = this.$canvas.appendTo(this.$container).get(0).getContext("2d"), this.points = [], this.fishes = [], this.watchIds = []
    },
    createSurfacePoints: function () {
      var t = Math.round(this.width / this.POINT_INTERVAL);
      this.pointInterval = this.width / (t - 1), this.points.push(new SURFACE_POINT(this, 0));
      for (var i = 1; i < t; i++) {
        var e = new SURFACE_POINT(this, i * this.pointInterval),
          h = this.points[i - 1];
        e.setPreviousPoint(h), h.setNextPoint(e), this.points.push(e)
      }
    },
    reconstructMethods: function () {
      this.watchWindowSize = this.watchWindowSize.bind(this), this.jdugeToStopResize = this.jdugeToStopResize.bind(this), this.startEpicenter = this.startEpicenter.bind(this), this.moveEpicenter = this.moveEpicenter.bind(this), this.reverseVertical = this.reverseVertical.bind(this), this.render = this.render.bind(this)
    },
    setup: function () {
      this.points.length = 0, this.fishes.length = 0, this.watchIds.length = 0, this.intervalCount = this.MAX_INTERVAL_COUNT, this.width = this.$container.width(), this.height = this.$container.height(), this.fishCount = this.FISH_COUNT * this.width / 500 * this.height / 500, this.$canvas.attr({
        width: this.width,
        height: this.height
      }), this.reverse = !1, this.fishes.push(new FISH(this)), this.createSurfacePoints()
    },
    watchWindowSize: function () {
      this.clearTimer(), this.tmpWidth = this.$window.width(), this.tmpHeight = this.$window.height(), this.watchIds.push(setTimeout(this.jdugeToStopResize, this.WATCH_INTERVAL))
    },
    clearTimer: function () {
      for (; this.watchIds.length > 0;) clearTimeout(this.watchIds.pop())
    },
    jdugeToStopResize: function () {
      var t = this.$window.width(),
        i = this.$window.height(),
        e = t == this.tmpWidth && i == this.tmpHeight;
      this.tmpWidth = t, this.tmpHeight = i, e && this.setup()
    },
    bindEvent: function () {
      this.$window.on("resize", this.watchWindowSize), this.$container.on("mouseenter", this.startEpicenter), this.$container.on("mousemove", this.moveEpicenter)
    },
    getAxis: function (t) {
      var i = this.$container.offset();
      return {
        x: t.clientX - i.left + this.$window.scrollLeft(),
        y: t.clientY - i.top + this.$window.scrollTop()
      }
    },
    startEpicenter: function (t) {
      this.axis = this.getAxis(t)
    },
    moveEpicenter: function (t) {
      var i = this.getAxis(t);
      this.axis || (this.axis = i), this.generateEpicenter(i.x, i.y, i.y - this.axis.y), this.axis = i
    },
    generateEpicenter: function (t, i, e) {
      if (!(i < this.height / 2 - this.THRESHOLD || i > this.height / 2 + this.THRESHOLD)) {
        var h = Math.round(t / this.pointInterval);
        h < 0 || h >= this.points.length || this.points[h].interfere(i, e)
      }
    },
    reverseVertical: function () {
      this.reverse = !this.reverse;
      for (var t = 0, i = this.fishes.length; t < i; t++) this.fishes[t].reverseVertical()
    },
    controlStatus: function () {
      for (var t = 0, i = this.points.length; t < i; t++) this.points[t].updateSelf();
      for (t = 0, i = this.points.length; t < i; t++) this.points[t].updateNeighbors();
      this.fishes.length < this.fishCount && 0 == --this.intervalCount && (this.intervalCount = this.MAX_INTERVAL_COUNT, this.fishes.push(new FISH(this)))
    },
    render: function () {
      requestAnimationFrame(this.render), this.controlStatus(), this.context.clearRect(0, 0, this.width, this.height), this.context.fillStyle = this.FISH_COLOR;
      for (var t = 0, i = this.fishes.length; t < i; t++) this.fishes[t].render(this.context);
      this.context.save(), this.context.globalCompositeOperation = "xor", this.context.beginPath(), this.context.moveTo(0, this.reverse ? 0 : this.height);
      for (t = 0, i = this.points.length; t < i; t++) this.points[t].render(this.context);
      this.context.lineTo(this.width, this.reverse ? 0 : this.height), this.context.closePath(), this.context.fill(), this.context.restore()
    }
  },
  SURFACE_POINT = function (t, i) {
    this.renderer = t, this.x = i, this.init()
  };
  SURFACE_POINT.prototype = {
    SPRING_CONSTANT: .03,
    SPRING_FRICTION: .9,
    WAVE_SPREAD: .3,
    ACCELARATION_RATE: .01,
    init: function () {
      this.initHeight = this.renderer.height * this.renderer.INIT_HEIGHT_RATE, this.height = this.initHeight, this.fy = 0, this.force = {
        previous: 0,
        next: 0
      }
    },
    setPreviousPoint: function (t) {
      this.previous = t
    },
    setNextPoint: function (t) {
      this.next = t
    },
    interfere: function (t, i) {
      this.fy = this.renderer.height * this.ACCELARATION_RATE * (this.renderer.height - this.height - t >= 0 ? -1 : 1) * Math.abs(i)
    },
    updateSelf: function () {
      this.fy += this.SPRING_CONSTANT * (this.initHeight - this.height), this.fy *= this.SPRING_FRICTION, this.height += this.fy
    },
    updateNeighbors: function () {
      this.previous && (this.force.previous = this.WAVE_SPREAD * (this.height - this.previous.height)), this.next && (this.force.next = this.WAVE_SPREAD * (this.height - this.next.height))
    },
    render: function (t) {
      this.previous && (this.previous.height += this.force.previous, this.previous.fy += this.force.previous), this.next && (this.next.height += this.force.next, this.next.fy += this.force.next), t.lineTo(this.x, this.renderer.height - this.height)
    }
  };
  var FISH = function (t) {
    this.renderer = t, this.init()
  };
  FISH.prototype = {
    GRAVITY: .4,
    init: function () {
      this.direction = Math.random() < .5, this.x = this.direction ? this.renderer.width + this.renderer.THRESHOLD : -this.renderer.THRESHOLD, this.previousY = this.y, this.vx = this.getRandomValue(4, 10) * (this.direction ? -1 : 1), this.renderer.reverse ? (this.y = this.getRandomValue(1 * this.renderer.height / 10, 4 * this.renderer.height / 10), this.vy = this.getRandomValue(2, 5), this.ay = this.getRandomValue(.05, .2)) : (this.y = this.getRandomValue(6 * this.renderer.height / 10, 9 * this.renderer.height / 10), this.vy = this.getRandomValue(-5, -2), this.ay = this.getRandomValue(-.2, -.05)), this.isOut = !1, this.theta = 0, this.phi = 0
    },
    getRandomValue: function (t, i) {
      return t + (i - t) * Math.random()
    },
    reverseVertical: function () {
      this.isOut = !this.isOut, this.ay *= -1
    },
    controlStatus: function (t) {
      this.previousY = this.y, this.x += this.vx, this.y += this.vy, this.vy += this.ay, this.renderer.reverse ? this.y > this.renderer.height * this.renderer.INIT_HEIGHT_RATE ? (this.vy -= this.GRAVITY, this.isOut = !0) : (this.isOut && (this.ay = this.getRandomValue(.05, .2)), this.isOut = !1) : this.y < this.renderer.height * this.renderer.INIT_HEIGHT_RATE ? (this.vy += this.GRAVITY, this.isOut = !0) : (this.isOut && (this.ay = this.getRandomValue(-.2, -.05)), this.isOut = !1), this.isOut || (this.theta += Math.PI / 20, this.theta %= 2 * Math.PI, this.phi += Math.PI / 30, this.phi %= 2 * Math.PI), this.renderer.generateEpicenter(this.x + (this.direction ? -1 : 1) * this.renderer.THRESHOLD, this.y, this.y - this.previousY), (this.vx > 0 && this.x > this.renderer.width + this.renderer.THRESHOLD || this.vx < 0 && this.x < -this.renderer.THRESHOLD) && this.init()
    },
    render: function (t) {
      t.save(), t.translate(this.x, this.y), t.rotate(Math.PI + Math.atan2(this.vy, this.vx)), t.scale(1, this.direction ? 1 : -1), t.beginPath(), t.moveTo(-30, 0), t.bezierCurveTo(-20, 15, 15, 10, 40, 0), t.bezierCurveTo(15, -10, -20, -15, -30, 0), t.fill(), t.save(), t.translate(40, 0), t.scale(.9 + .2 * Math.sin(this.theta), 1), t.beginPath(), t.moveTo(0, 0), t.quadraticCurveTo(5, 10, 20, 8), t.quadraticCurveTo(12, 5, 10, 0), t.quadraticCurveTo(12, -5, 20, -8), t.quadraticCurveTo(5, -10, 0, 0), t.fill(), t.restore(), t.save(), t.translate(-3, 0), t.rotate((Math.PI / 3 + Math.PI / 10 * Math.sin(this.phi)) * (this.renderer.reverse ? -1 : 1)), t.beginPath(), this.renderer.reverse ? (t.moveTo(5, 0), t.bezierCurveTo(10, 10, 10, 30, 0, 40), t.bezierCurveTo(-12, 25, -8, 10, 0, 0)) : (t.moveTo(-5, 0), t.bezierCurveTo(-10, -10, -10, -30, 0, -40), t.bezierCurveTo(12, -25, 8, -10, 0, 0)), t.closePath(), t.fill(), t.restore(), t.restore(), this.controlStatus(t)
    }
  }, $(function () {
    RENDERER.init()
    $('.dark').click(function () {
      setTimeout(() => {
        RENDERER.setFishColor();
        RENDERER.context.fill();
      });
    })
  });
</script>
  
  <div class="footer bg-color">
    <div class="footer-main">
      
        
          <div class="link">
            
          </div>
        
      
        
          <div class="footer-copyright">
            <p>Copyright © 2022 <a target="_blank" rel="noopener" href="https://github.com/hnuyl16">hnuyl16</a> | Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/yuang01/theme">Bamboo</a> </p>

          </div>
        
      
        
          <div class="footer-custom">
            
          </div>
        
      
    </div>
  </div>



    <!-- 渲染暗黑按钮 -->
    
      <div class="dark" onclick="toggleDarkMode()">
  <div class="dark-content">
    <i class="fas" id="darkIcon" aria-hidden="true"></i>
  </div>
</div>

<script defer>
  $(function() {
    // 初始化暗黑模式状态
    let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');
    updateDarkModeIcon(isDark);
  });

  function toggleDarkMode() {
    const isDark = $(document.body).hasClass('darkModel');
    $(document.body).toggleClass('darkModel');
    localStorage.setItem('dark', !isDark);
    updateDarkModeIcon(!isDark);
  }

  function updateDarkModeIcon(isDark) {
    const iconElement = document.getElementById('darkIcon');
    if (isDark) {
      iconElement.classList.remove('fa-moon');
      iconElement.classList.add('fa-lightbulb');
    } else {
      iconElement.classList.remove('fa-lightbulb');
      iconElement.classList.add('fa-moon');
    }
  }
</script>

    
    <!-- 渲染回到顶部按钮 -->
    
      <div class="goTop top-btn-color" pointer>
  <i class="fas fa-arrow-up" aria-hidden="true"></i>
</div>
<script defer src="/js/goTop.js"></script>

    
    <!-- 渲染左下角音乐播放器 -->
    
      <link rel="stylesheet" href="/js/aplayer/APlayer@1.10.1.min.css">
<style>
.aplayer .aplayer-lrc p {
  
  font-size: 12px;
  font-weight: 700;
  line-height: 16px !important;
}

.aplayer .aplayer-lrc p.aplayer-lrc-current {
  
  font-size: 15px;
  color: #42b983;
}


.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
  left: -66px !important;
}

.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
  left: 0px !important;
}


</style>
<meting-js  
  class=""
  server="tencent"
  type="playlist"
  id="8062553743"
  fixed='true'
  autoplay='false'
  theme='#42b983'
  loop='all'
  order='random'
  preload='auto'
  volume='0.7'
  list-folded='true'
>
</meting-js>

<!-- <style>
  #aplayer {
    position: fixed;
    left: 0;
    bottom: 300px;
  }
</style> -->
<script defer src="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.js"></script>
<script defer src="https://unpkg.com/meting@2/dist/Meting.min.js"></script>
    

    <!-- 图片放大 -->
    
      <script src="https://unpkg.com/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js"></script>
    

    <!-- 百度解析 -->
    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script async>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <!-- 背景彩带 -->
    
      <script async type="text/javascript" size="100" alpha='0.4' zIndex="-1" src="/js/ribbon.min.js"></script>
    

    <script src="/js/utils/index.js"></script>
    <script src="/js/app.js"></script>
    
    <!-- 文章目录所需js -->
<!-- <link href="/js/tocbot/tocbot.css" rel="stylesheet">
<script src="/js/tocbot/tocbot.min.js"></script> -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.min.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.css">

<script>
  var headerEl = 'h2, h3, h4',  //headers 
    content = '.post-detail',//文章容器
    idArr = {};  //标题数组以确定是否增加索引id
  //add #id
  var option = {
    // Where to render the table of contents.
    tocSelector: '.toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: content,
    // Which headings to grab inside of the contentSelector element.
    headingSelector: headerEl,
    scrollSmooth: true,
    scrollSmoothOffset: -70,
    // headingsOffset: -($(window).height() * 0.4 - 45),
    headingsOffset: -($(window).height() * 0.4 - 70),
    // positionFixedSelector: '.toc-main',
    // positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    activeLinkClass: 'is-active-link',
    orderedList: true,
    collapseDepth: 20,
    // onClick: function (e) {},
  }
  if ($('.toc').length > 0) {

    $(content).children(headerEl).each(function () {
      //去除空格以及多余标点
      var headerId = $(this).text().replace(/[\s|\~|`|\!|\@|\#|\$|\%|\^|\&|\*|\(|\)|\_|\+|\=|\||\|\[|\]|\{|\}|\;|\:|\"|\'|\,|\<|\.|\>|\/|\?|\：|\，|\。]/g, '');

      headerId = headerId.toLowerCase();
      if (idArr[headerId]) {
        //id已经存在
        $(this).attr('id', headerId + '-' + idArr[headerId]);
        idArr[headerId]++;
      }
      else {
        //id未存在
        idArr[headerId] = 1;
        $(this).attr('id', headerId);
      }
    });

    document.addEventListener("DOMContentLoaded", function () {
      tocbot.init(option);
      mobileTocClick();
    });

  }

  window.tocScrollFn = function () {
    return bamboo.throttle(function () {
      findHeadPosition();
    }, 100)()
  }
  window.addEventListener('scroll', tocScrollFn);

  const findHeadPosition = function (top) {
    if ($('.toc-list').length <= 0) {
      return false;
    }
    setTimeout(() => {  // or DOMContentLoaded 
      autoScrollToc();
    }, 0);
  }

  const autoScrollToc = function () {
    const $activeItem = document.querySelector('.is-active-link');
    const $cardToc = document.querySelector('.toc-content');
    const activePosition = $activeItem.getBoundingClientRect().top
    const sidebarScrollTop = $cardToc.scrollTop
    if (activePosition > (document.documentElement.clientHeight - 100)) {
      $cardToc.scrollTop = sidebarScrollTop + 150
    }
    if (activePosition < 150) {
      $cardToc.scrollTop = sidebarScrollTop - 150
    }
  }

  document.addEventListener('pjax:send', function () {
    if ($('.toc').length) {
      tocbot.destroy();
    }
  });

  document.addEventListener('pjax:complete', function () {
    if ($('.toc').length) {
      tocbot.init(option);
      mobileTocClick();
    }
  });
  
  // 手机端toc按钮点击出现目录
  const mobileTocClick = function () {
    const $cardTocLayout = document.getElementsByClassName('side_toc')[0];
    const $cardToc = $cardTocLayout.getElementsByClassName('toc-content')[0];
    let right = '45px';
    if (window.innerWidth >= 551 && window.innerWidth <= 992) {
      right = '100px'
    }
    const mobileToc = {
      open: () => {
        $cardTocLayout.style.cssText = 'animation: toc-open .3s; opacity: 1; right: ' + right
      },

      close: () => {
        $cardTocLayout.style.animation = 'toc-close .2s'
        setTimeout(() => {
          $cardTocLayout.style.cssText = "opacity:''; animation: ''; right: ''"
        }, 100)
      }
    }
    document.getElementById('toc-mobile-btn').addEventListener('click', () => {
      if (window.getComputedStyle($cardTocLayout).getPropertyValue('opacity') === '0') mobileToc.open()
      else mobileToc.close()
    })

    $cardToc.addEventListener('click', (e) => {
      if (window.innerWidth < 992) { // 小于992px的时候
        mobileToc.close()
      }
    })
  }
</script>

<style>
  /* .is-position-fixed {
    position: sticky !important;
    top: 74px;
  }

  .toc-main ul {
    counter-reset: show-list;
  }

  .toc-main ul li::before {
    content: counter(item)".";
    display: block;
    position: absolute;
    left: 12px;
    top: 0;
  } */
</style>
 

<!-- 设置导航背景 -->
<script>
  let setHeaderClass = () => {
    const nav = $('#navHeader');
    const navTop = nav.outerHeight();
    const winTop = $(window).scrollTop();
    if(winTop > navTop) {
      nav.addClass('header-bg-color');
    }
    else {
      nav.removeClass('header-bg-color');
    }
  };

  let scrollCollect = () => {
    return bamboo.throttle(function (e) {
      setHeaderClass();
    }, 200)()
  }

  let initHeaderBg = () => {
    setHeaderClass();
  }

  setHeaderClass();
  window.addEventListener('scroll', scrollCollect);

  document.addEventListener('pjax:send', function () {
    window.removeEventListener('scroll', scrollCollect)
  })
  document.addEventListener('pjax:complete', function () {
    window.addEventListener('scroll', scrollCollect);
    setHeaderClass();
  })
</script> 

<!-- 渲染issues标签里的内容 -->
<script>
  function loadIssuesJS() {
    if ($(".post-detail").find(".issues-api").length == 0) {
      return;
    } 
    loadScript('/js/issues/index.js');
  };
  $(function () {
    loadIssuesJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof IssuesAPI == "undefined") {
      loadIssuesJS();
    }
  })
</script>

<!-- 渲染远程json加载的图片标签(getPhotoOnline)里的内容 -->
<script>
  function loadPhotoOnlineJS() {
    if ($(".post-detail").find(".getJsonPhoto-api").length == 0) {
      return;
    } 
    loadScript('/js/getPhotoOnline/index.js');
  };
  $(function () {
    loadPhotoOnlineJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof getPhotoJson == "undefined") {
      loadPhotoOnlineJS();
    }
  })
</script>

<!-- 渲染远程json加载的talk标签(getTalkOnline)里的内容 -->
<script>
  function loadTalkOnlineJS() {
    if ($(".post-detail").find(".getJsonTalk-api").length == 0) {
      return;
    } 
    loadScript('https://cdnjs.cloudflare.com/ajax/libs/waterfall.js/1.0.2/waterfall.min.js'); // 瀑布流插件，https://raphamorim.io/waterfall.js/
    loadScript('/js/getTalkOnline/index.js');
  };
  $(function () {
    loadTalkOnlineJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof getTalkJson == "undefined") {
      loadTalkOnlineJS();
    }
  })
</script>

<!-- 渲染远程json加载的site-card标签(getSiteOnline)里的内容 -->
<script>
  function loadSiteOnlineJS() {
    if ($(".post-detail").find(".getJsonSite-api").length == 0) {
      return;
    } 
    loadScript('/js/getSiteOnline/index.js');
  };
  $(function () {
    loadSiteOnlineJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof getSiteJson == "undefined") {
      loadSiteOnlineJS();
    }
  })
</script>

<!-- 输入框打字特效 -->
<!-- 输入框打字特效 -->

  <script src="/js/activate-power-mode.js"></script>
  <script>
    POWERMODE.colorful = true;  // 打开随机颜色特效
    POWERMODE.shake = false;    // 关闭输入框抖动
    document.body.addEventListener('input', POWERMODE);//监听打字事件
  </script>


<!-- markdown代码一键复制功能 -->

  <link rel="stylesheet" href="https://unpkg.com/v-plugs-ayu/lib/ayu.css">
  <script src="https://unpkg.com/v-plugs-ayu/lib/ayu.umd.min.js"></script>
  <script src="/js/clipboard/clipboard.min.js"></script>
  <div id="appCopy">
  </div>
  <script data-pjax>
    var vm = new Vue({
      el: '#appCopy',
      data: {
      },
      computed: {
      },
      mounted() {
        const that = this;
        var copy = '复制';
        /* code */
        var initCopyCode = function () {
          var copyHtml = '';
          copyHtml += '<button class="btn-copy" data-clipboard-snippet="" style="position:absolute;top:0;right:0;z-index:1;">';
          copyHtml += '<i class="fas fa-copy"></i><span>' + copy + '</span>';
          copyHtml += '</button>';
          $(".post-detail pre").not('.gutter pre').wrap("<div class='codeBox' style='position:relative;width:100%;'></div>")
          $(".post-detail pre").not('.gutter pre').before(copyHtml);
          new ClipboardJS('.btn-copy', {
            target: function (trigger) {
              return trigger.nextElementSibling;
            }
          });
        }
        initCopyCode();
        $('.btn-copy').unbind('click').bind('click', function () {
          doSomething();
        })
        $(document).unbind('keypress').bind('keypress', function (e) {
          if (e.ctrlKey && e.keyCode == 67) {
            doSomething();
          }
        })

        function doSomething() {
          that.$notify({
            title: "成功",
            content: "代码已复制，请遵守相关授权协议。",
            type: 'success'
          })
        }
      },
      methods: {
      },
      created() { }
    })
  </script>
  

<!-- 图片懒加载 -->
<script defer src="https://unpkg.com/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>


<!-- 卡片滚动动画 -->
   

<!-- 评论所需js -->

  
        <script type="text/javascript">
  var utteranceComment = {};

  function check_utterance() {
    let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');
    if (isDark) {
      utteranceComment.Theme = 'github-dark';
    } else {
      utteranceComment.Theme = 'github-light';
    }

    return document.getElementById("gitment-container");
  }
  comment_el = '#gitment-container';
  load_utterance = function () {
    if ($(comment_el).length) {
      // 匿名函数，防止污染全局变量
      const HEAD = check_utterance();

      var utterances = document.createElement('script');
      utterances.type = 'text/javascript';
      utterances.async = true;
      utterances.setAttribute('issue-term', 'pathname')
      utterances.setAttribute('theme', utteranceComment.Theme)
      utterances.setAttribute('repo', '')
      utterances.crossorigin = 'anonymous';
      utterances.src = 'https://utteranc.es/client.js';
      // content 是要插入评论的地方
      document.getElementById('gitment-container').appendChild(utterances);

    }
  }

  function dark_utterance() {
    const HEAD = check_utterance();
    if (!HEAD) return;
    const message = {
      type: 'set-theme',
      theme: utteranceComment.Theme
    };
    const utteranceIframe = document.querySelector('iframe');
    utteranceIframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }

  $(document).ready(load_utterance);
  document.addEventListener('pjax:complete', function () {
    load_utterance();
  });

  $('.dark').click(function () {
    setTimeout(() => {
      dark_utterance();
    });
  })

</script>

<style>
  .utterances {
    max-width: inherit !important;
  }
</style>
      


<!-- 鼠标点击特效 -->
<!-- 爱心点击 -->

  
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 999; pointer-events: none;" ></canvas>
    <script async src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script async src="/js/cursor/explosion.min.js"></script>
  




  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" data-pjax></script>


<!-- 轮播图标签 -->
<script>
  var bambooSwiperTag = {};
  function load_swiper() {
    if (!document.querySelectorAll(".post-swiper-container")[0]) return;
    loadCSS("https://unpkg.com/swiper@6/swiper-bundle.min.css")
    loadScript("https://unpkg.com/swiper@6/swiper-bundle.min.js").then(() => {
      pjax_swiper();
    });
  }

  load_swiper();

  function pjax_swiper() {
    bambooSwiperTag.swiper = new Swiper('.post-swiper-container', {
      slidesPerView: 'auto',
      spaceBetween: 8,
      centeredSlides: true,
      loop: true,
      autoplay: true ? {
        delay: 3000,
        stopOnLastSlide: false,
        disableOnInteraction: false,
      } : false,
      pagination: {
        el: '.swiper-pagination',
        clickable: true,
      },
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-button-prev',
      },
      on:{
        init: function(){
          swiperAnimateCache(this); //隐藏动画元素 
          swiperAnimate(this); //初始化完成开始动画
        }, 
        slideChangeTransitionEnd: function(){ 
          swiperAnimate(this); //每个slide切换结束时也运行当前slide动画
          //this.slides.eq(this.activeIndex).find('.ani').removeClass('ani'); 动画只展现一次，去除ani类名
        } 
      }
    });
  }

  document.addEventListener('pjax:complete', function () {
    if (!document.querySelectorAll(".post-swiper-container")[0]) return;
    if (typeof bambooSwiperTag.swiper === "undefined") {
      load_swiper();
    } else {
      pjax_swiper();
    }
  });
</script>
    <!-- pjax -->
    

<!-- pjax -->


  <script src="/js/pjax@0.2.8/index.js"></script>
  
    <div class="pjax-animate">
  
    <div class="loading-circle"><div id="loader-circle"></div></div>
    <script>
      window.ShowLoading = function() {
        $(".loading-circle").css("display", "block");
      };
      window.HideLoading = function() {
        $(".loading-circle").css("display", "none");
      }
    </script>
  
	<script>
    document.addEventListener('pjax:complete', function () {
      window.HideLoading();
    })
    document.addEventListener('pjax:send', function () {
      window.ShowLoading();
    })
    document.addEventListener('pjax:error', function () {
      window.HideLoading();
    })
	</script>
</div>

  

  <script>
    var pjax = new Pjax({
      elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([no-pjax])',   // 拦截正常带链接的 a 标签
      selectors: ["#pjax-container","title"],                                   // 根据实际需要确认重载区域
      cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
      timeout: 5000
    });

    document.addEventListener('pjax:send', function (e) {

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');

    })
    
    document.addEventListener('pjax:complete', function () {
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
    });

    document.addEventListener('pjax:error', function (e) {
      window.location.href = e.triggerElement.href;
    })
    
    // 刷新不从顶部开始
    document.addEventListener("DOMContentLoaded", function () {
      history.scrollRestoration = 'auto';
    })
  </script>



  </body>
</html>